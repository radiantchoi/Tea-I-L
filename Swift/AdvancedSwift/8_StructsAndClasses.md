# Structs and Classes
- Swift에는 `struct`와 `class`라는 굉장히 비슷해 보이는 두 가지 선택지가 있다.
- 하지만 이쯤 되면 알지, 둘은 근본적으로 다르다는 것을.
- `struct`는 값 타입, `class`는 참조 타입.

## Value Typees and Reference Types
- 둘의 가장 근본적인 차이는 값의 복사 할당의 방식에 있다.
- 값 타입은 각각의 독립적인 값을 가지며, 이를 value semantics라고도 부른다.
- 그런데 도대체 변수가 뭘까? 한 마디로 말하면, 어떤 타입의 값을 저장하고 있는 메모리 위치에 붙인 이름이다.
- `var a = 1; a += 1`은, a라고 이름붙인 메모리 주소 상의 값을 따와서, 1을 더하고, 더한 값을 a 메모리에 다시 저장하는 것이다.
- 값 타입의 경우, 변수 뒤에 있는 메모리에 바로 할당이 되어 있다. 에잇 뭔 말인지 알지?
    - 이는 기본 타입부터 한층 복잡한 `struct`까지 모두 유효한 말이다.
- 한편 참조 타입은 복사를 해도..
```Swift
var view1 = UIView(frame: CGRect(x: 0, y: 0, width: 100, height: 100))
var view2 = view1
view2.frame.origin = CGPoint(x: 50, y: 50)

view1.frame.origin // (50, 50)
view2.frame.origin // (50, 50)
```
- 뷰 1과 2가 같다는 것을 어렴풋이 느낄 수 있지?!
- 참조 타입 프로퍼티는 값 그 자체가 아닌 값이 할당되어 있는 메모리 주소를 가리키는 참조를 갖기 때문이다.
- 참조 타입은 존재하는 무언가 그 자체를 갖지 않고, 참조한다. 포인터를 갖는다고 하자!
    - 이는 또한 reference semantics라고도 할 수 있다.
- 이 "포인터" 덕분에, 프로그램의 여러 다른 부분에서 이 객체에 접근할 수 있다.
- 아무튼! `struct`를 다른 변수에 할당하는 것은 독립적인 복사본을 만든다.
- 비슷하게, 함수 파라미터로 전달하는 것 또한 독립적인 복사본을 만든다!
- 그리고 이 파라미터로 전달된 값은 불변값이다.
- 값 타입을 직접 바꾸려면, `inout` 파라미터를 사용해야 한다.
- 클래스가 좀 더 유능하긴 한데, 이 유능함은 또한 비용이 되기도 한다.
- Vice versa. 구조체는 더 제한이 많지만, 이 제한이 이득이 될 때도 있다.

## Mutation
- 구조체와 클래스는 값을 바꿔야 할 때 그 차이가 더욱 더 크게 와 닿는다.
- 구조체의 변경은 지역적 변경인 반면, 클래스의 변경은 전역적인 영향을 끼칠 소지가 있다.
- `let` 변수에 클래스를 할당하면 클래스 인스턴스를 변경할 수 있지만, 구조체는 그렇게 안 된다.
- `let`으로 선언한다는 것은 사실 초기화 이후에 변경을 하지 않을 것이라는 선언이다.
- 하지만 참조 타입에 있어, 이는 단지 이 변수에 할당한 클래스 인스턴스를 바꿀 수 없다는 정도의 제약이다.
    - 이 인스턴스 내부의 `var` 프로퍼티를 변경하는 것은 자유롭다.
- 값 타입을 `let`으로 선언했다면, 이건 진짜로 그 실제 값을 가지고 있는 경우다. 따라서 바꿀 수 없다. 프로퍼티조차도.
    - 구조체의 프로퍼티를 변경한다는 것은, 새 구조체를 할당한다는 말과 같기 때문이다.
    - 이는 구조체 내부의 프로퍼티(구조체) 내부의 프로퍼티.. 를 바꾸는 경우에도 마찬가지이다.
- 한편 클래스 내부의 값 타입 프로퍼티가 `let`으로 설정되어 있다면, 마찬가지로 바꿀 수 없다.
- 값 타입 프로퍼티에서는 `var`를 기본적으로 쓰는 것을 추천한다.
- 참조 타입 프로퍼티는 `var`로 정의하면 전역적 변화의 위험이 있지만, 값 타입은 그렇지 않다.

### Mutating Methods
- 구조체에 있는 일반적인 메서드들은 그 구조체의 어떠한 프로퍼티도 변경할 수 없다.
- 모든 함수의 파라미터에 암시적으로 할당되는 `self`가, `let`으로 설정된 것 처럼 불변하기 때문.
- 정 프로퍼티를 변경하고 싶다면, `mutating` 키워드를 함수 앞에 붙여 줘야 한다.
- 컴파일러는 `mutating` 키워드를, `let`으로 선언되었을 때 불러올 수 없는 메서드를 표시하는 수단으로 인식한다!!
    - `let` 변수는 불변한데, `mutating` 함수는 내부의 프로퍼티를 바꿈으로써 새 구조체 인스턴스를 변수에 넣을 수 있으니.
- 프로퍼티와 `subscript`의 setter는 암시적으로 `mutating`이다.
- 가끔 setter가 `mutating`하지 않은 연산 프로퍼티를 정의하고 싶다면, `nonmutating` 키워드를 `set` 앞에 붙여 주면 된다.
- 한편 클래스는 이런 키워드가 필요하지 않다. 앞에서 봤듯, `var`로 정의되어 있다면 그냥 바꾸면 된다.

### inout Parameters
- `mutating` 메서드는 변경 가능한 `self`에 접근 가능하게 함으로써 그 모든 프로퍼티에 접근 가능하다.
- `inout` 파라미터를 가진 메서드는 프로퍼티 중 하나를 콕 집어서 접근할 수 있게 한다.
- `inout`을 쓰려면 두 가지를 먼저 해야 한다.
    - 당연히 `var` 프로퍼티에 접근해야 한다.
    - 변수 이름 앞에 `&`를 붙여 줘야 한다.
- 이 앰퍼샌드는 C 혹은 Obj-C에서의 포인터 같은 느낌이 들겠지만, 그것과는 다르게 동작한다.
- 여타 파라미터처럼, 파라미터로 입력받는 값의 복사본을 전달한다.
- 단지 함수 실행이 끝난 후 원래 프로퍼티로 다시 복사되어 반영된다는 차이가 있는 것이다.
- 함수를 실행한 사람은 단지 실행이 끝나고 나니 프로퍼티 값이 바뀌어 있더라, 정도만 볼 수 있다.
- 그렇기 때문에, `inout` 파라미터로 전달받은 값에 변환을 가하지 않더라도 이 복사 - 재복사의 과정은 동작한다.
    - `willSet` 혹은 `didSet`이 작동하는 걸 볼 수 있을 것

# Lifecycle
- 구조체와 클래스는 그 라이프사이클의 측면에서 사뭇 다르다.
- 구조체는 오우너가 둘 이상이 될 수 없기 때문에 해당 변수의 라이프사이클에 매여 있다.
- 한편 클래스는 여러 오우너로부터 소유당할 수 있고, 더 정밀한 메모리 관리가 필요하다.
    - 그래서 등장한 ARC!
    - reference count가 0이 되면 deinit을 호출하고 메모리를 비운다.
    - 이러한 클래스의 "공유 가능" 특성 덕에 파일 핸들링이나, 뷰 컨트롤러 등에 쓰인다.

## Reference Cycles
- 둘 이상의 객체가 서로를 강하게 참조하고 있어서(참조를 들고 있어서) 해제될 수 없게 되는 경우.
- 메모리 누수, 클리닝 과정의 누락 등의 문제가 있다.
- 당연하지만 값 타입인 구조체 사이에는 순환 참조가 발생할 수 없다.
    - 근데 오히려 그래서, 사이클릭한 자료구조는 구조체로 만들 수 없다.
- 순환 참조는 두 개의 객체 간에서 발생하는 것부터 객체와 객체 간의 복잡한 의존 관계까지, 다양하다.
```Swift
class Window {
    var rootView: View?
}

class View {
    // 예시 코드긴 한데 사실 여기서부터 순환 냄새를 맡아버림
    // window 프로퍼티는 옵셔널이 되는 게 맞다
    var window: Window
    
    init(window: Window) {
        self.window = window
    }
}

var window: Window? = Window() // 1
window = nil // 0

var window: Window? = Window() // 1, 0
var view: View? = View(window: window!) // 2, 1
window?.rootView = view // 2, 2
view = nil // 2, 1
window = nil // 1, 1
```
- 그래프 같은 자료구조를 다룰 때, 이러한 순환 참조로 인한 메모리 누수에 대해 유의할 필요가 있다.