# 컴퓨터 내부 구조
- 전기를 비트로 만들기, 비트로 하드웨어를 만들기, 전자 부품을 조합하기..
- 비트를 조작하는 회로를 컴퓨터라고 한다.
- 현대적 컴퓨터: 메모리 / 입출력 / CPU

## 메모리
- 조작한 비트를 저장할 장소
- 얼마간의 비틀르 저장할 수 있는 집이 늘어서 있는 것과 같다.
- 집집마다 주소를 부여한다.
- 메모리를 읽어들이는 단위가 크면, 한 번에 더 많은 데이터를 데이터 버스에 실을 수 있다.
  - 32비트 컴퓨터느 4바이트 덩어리, 64비트 컴퓨터는 8바이트 덩어리
  - 사실 32비트 컴퓨터 메모리를 예로 들면, 집 1개씩 붙은 집 2개짜리 집이 2개 붙어 있는 걸로 생각할 수도 있다.
- 다양한 메모리들은 서로 다른 가성비(진짜)를 가지고 있다!
- 데이터는 하나의 집에 들어갈 만큼의 단위로 쪼개져서 저장되고, 여러 집에 걸쳐져 있는 경우는 정렬이 맞지 않는 접근이라고 부른다.
  - 그래서 긴 워드(책에서는 32비트)의 주소를 지정하는 방법은 1바이트의 주소를 지정하는 법과 다르다.
- 긴 워드의 가장 왼쪽 자리에는 0번 바이트가 들어갈까, 3번 바이트가 들어갈까? 이 차이는 엔디안이라는 용어로 표현된다.
  - 빅 엔디안, 리틀 엔디안
  - 시스템마다 다르기 때문에, 데이터 전송 시에는 엔디안을 염두에 둬야 한다.

## 입력과 출력
- 컴퓨터에서 정보를 가져오고, 정보를 내보내는 것.
- I/O Device, 주변기기Peripheral
- CPU에는 메모리 버스뿐만 아니라 인아웃 작업을 위한 별도의 경로가 있다.
  - 그렇긴 한데, 요즘은 컴퓨터 비트가 32 64 이래 되다 보니 실제 메모리가 할당되지 않은 주소가 많아졌다.
  - 그리고 그 남는 주소를 인아웃 장치에 할당하는 것이 타당해졌다.
  - 그리고 그렇게 되면 같은 버스를 쓰게 된다. !!!

## 중앙 처리 장치 (CPU)

### 산술 논리 장치 (ALU)
- 산술 계산, 불리언 대수 및 기타 연산을 수행
- 피연산자와 연산 코드를 입력받아 결과와 조건 코드를 출력한다.
  - 피연산자는 수를 표현하는 비트
  - 연산 코드 혹은 명령 코드는 어떤 연산자를 적용할지 지정
  - 결과는 적용 결과(...)
  - 조건 코드는 결과에 대한 추가 정보.
- 전형적인 조건 코드 레지스터 p.171
  - N은 음수일 경우 1로
  - Z는 마지막 연산 결과가 0인 경우 1로
  - O 비트는 오버플로우, 언더플로우가 발생한 경우 1로 설정된다.
- ALU 명령 코드 p.171
- 사실 셀렉터와 논리 게이트를 연결한 것일 뿐!

### 시프트
- 왼쪽 시프트는 모든 비트를 왼쪽으로 밀고 가장 왼쪽의 비트(MSB)는 버리고 오른쪽(LSB)에 0을 채워 넣는다.
  - 반대도 당연히 성립하겠죵
  - 이 때 버린 비트가 필요할 때가 있을 수 있으므로 이것이 조건 레지스터에 저장한다..
- 클럭에 따라 내용을 1비트씩 시프트하는 시프트 레지스터를 플립플롭을 사용해 만들 수 있다.
- 순차적인 시프트 레지스터를 1비트당 1클럭씩 걸리기 때문에 느리다.
  - 셀렉터와 배럴 시프터를 활용해 이를 해결할 수 있다.
  - 8비트 시프터를 만들려면 8:1 셀렉터가 8개 필요하다.
- ALU에 곱셈과 나눗셈이 없는데, 예를 들어 곱셈은 덧셈을 반복해도 되고, 비트를 왼쪽으로 하나 이동하는 게 곱하기 2의 효과도 있고.
- 시프터는 Floating Point 연산 구현시에도 핵심 부품이다. 소수점을 맞추고 더하거나 뺄 수 있다.

### 실행 장치
- 할 일을 알려주는 장치.
- 메모리에서 명령코드와 피연산자를 가져와서 연산을 시키고, 결과를 메모리에 돌려 준다.
- 그럼 명령은 어떻게 알까? 미리 입력된 명령어를 제공하는 방법이 있다.
  - 다름아닌 메모리에서 찾아올 수 있다.
  - "프로그램 저장 방식 컴퓨터" by 앨런 튜링
- 명령어란 컴퓨터에게 어떤 일을 할지 알려주는 비트 패턴이며, CPU마다 고유한 설계에 속한다.
- 실행 장치는 메모리에서 명령어를 가져와야 하는 위치를 파악하기 위해 프로그램 카운터를 사용한다.
  - 프로그램 카운터는 메모리 주소를 참조한다.
  - CPU마다 정해진 초기 프로그램 카운터 값이 있다.
  - 프로그램 카운터 값을 바꾸는 명령어를 수행하는 게 아니라면, 명령어를 수행하면 다음 위치를 가리키도록 프로그램 카운터가 증가된다.

## 명령어 집합
- 16비트 명령어를 명령 코드, 피연산자 두 개, 결과라는 네 가지 필드로 나눈다고 하면..
  - 결과에 쓸 수 있는 공간이 너무 좁다!
- 주소 확장 레지스터를 두고 별도의 명령어를 사용해 상위 주소를 지정하는 DRAM 주소 기법을 쓴다면?
  - 물리 주소 확장
  - 이런 것들이 으레 그렇듯 오버헤드가 심하다.
  - 그리고 만약, 메모리 주소가 각기 다른 장치에 퍼져 있다면, 한 곳으로 모아 주는 별도의 명령어도 써야 하는데.
  - 같은 CPU 핀을 공유하면서 다른 클럭에 작동하는 수 밖에 없다.. 그러면 버스도 3벌이나 될 필요가 없다.
  - 이 경우 피연산자 둘을 저장하는 레지스터를 추가해 명령어를 처리할 수 있다.
    - 피연산자를 각각 읽어올 때마다 레지스터에 저장하고, 결과가 나오면 결과 부분의 주소에 저장하고...
  - 이 방식을 쓰려면 명령어를 처리하기 위해 네 번의 클럭이 필요하다. 
  - 중요한 것은, 한 번에 한 메모리 위치에만 접근할 수 있다는 것을 상기하고 명령어 집합을 설계해야 한다는 것.
- 레지스터에 누산기를 추가하면 위의 방법이 가능하다.
  - ALU의 계산 결과를 저장한다. A 레지스터라고도 한다.
  - 두 메모리 위치 사이의 값을 계산해서 메모리로 다시 전송하는 대신, 한 메모리와 누산기에 있는 값을 계산해 결과를 누산기에 넣는다.
  - 물론 누산기의 값을 메모리에 넣기 위한 저장 명령어가 필요하지만.
- 누산기를 활용하는 것이 결과적으로는 명령어 비트 수를 줄일 수 있어서 더 효율적이다.
  - 어차피 피연산자 두 개랑 결과, 명령어 비트가 다 있어야 하기 때문.

### 주소 지정 모드
- 명령 코드의 주소 지정 모드, 라고 생각해도 좋다.
- 사용할 주소가 명령어에 입력되어 있는 것을 직접 주소 지정이라고 부른다.
- 간접 주소 지정도 당연히 있겠지.
  - 명령어에 들어 있는 값을 피연산자의 주소로 해석하지 않고, 피연산자 주소를 얻을 수 있는 메모리 위치의 주소로 여긴다.
- 상수를 써야 할 경우를 위해 즉시 주소 지정 모드란 것도 있다.
- 요컨대
  - 직접 주소 지정은 명령어에 피연산자 주소값이 들어 있다.
  - 간접 주소 지정은 명령어에 피연산자 주소값을 얻을 수 있는 주소값이 들어 있다.
  - 즉시 주소 지정은 명령어에 피연산자가 들어 있다(!!!).

### 조건 코드 명령어
- 조건 코드를 원하는 값으로 설정하고 싶다면? 조건 코드의 값을 살펴보고 싶다면?
- 조건 코드 레지스터의 값을 누산기로 복사하는 cca, 누산기의 값을 조건 코드 레지스터에 복사하는 acc

### 분기 명령어
- 지금은 명령어를 처음부터 끝까지 순차적으로 수행한다.
- 그런데 코드 중 일부를 의사결정에 따라 선택적으로 수행하고자 한다면? 분기 명령어를 사용하면 된다.
  - 특히 조건 코드를 살펴 보고 조건 만족 시 분기할 수 있다는 것이 핵심!
- 조건 저장을 위한 비트가 필요하긴 하다. p181
  - 특히 프로그램 카운터의 내용을 명시적으로 바꿔야 할 때 pca(카운터 -> 누산기), apc(누산기 -> 카운터)

### 최종 명령어 집합 구성
- 세 가지의 주소 지정 모드를 위한 2비트
  - 4번은 메모리와 관계 없는 연산일 때
- 주소 지정 모드와 명령 코드를 디코딩하면 얻을 수 있는 명령어 p182
- 이 "명령"의 뭉치인 프로그램을 작성해 실제 컴퓨터에게 뭘 하라고 시킬 수 있다.
- 200 이하의 피보나치 수 구하기, 그리고 그것을 명령어로 하는 과정 p183

## 마지막 설계

### 명령어 레지스터
- 컴퓨터는 사실 페치 <-> 실행의 두 단계로 이루어진 상태 기계이다.
- 명령어를 실행하려면 메모리에 접근해야 한다.
  - 그런데 명령어 수행 말고 다른 목적으로 메모리에 접근할 때도 있다.
  - 이럴 때 페치해 둔 명령어에 접근하기 쉬울 필요가 있다.
  - 이를 위해 CPU에는 명령어 레지스터가 추가되어, 현재 실행중인 명령어를 저장한다.

### 데이터 경로와 제어 신호
- 프로그램 카운터의 값을 메모리 주소 버스에 넣고, 메모리의 데이터를 명령어 레지스터로 넣는 방법이 필요하다.
- p185의 그림처럼 연결이 생긴다. 실제로는 앞에서 봤던 것들의 뭉치 같은 거다. 실제 설계는 이보다 훨씬 복잡하다.
- 한편 간접 주소 지정시 메모리에서 읽어온 주소를 저장하기 위한 간접 주소 레지스터가 추가된다.

### 데이터 흐름 제어
- 어떤 명령어든 처리하려면 페치해야 하고, 페치하려면..
  - 주소 소스는 프로그램 카운터를 선택한다.
  - 메모리를 동작시키고(enable을 1로 만든다는 뜻) 읽기 모드로 설정한다(r/w 값은 1).
  - 명령어 레지스터를 동작시켜야 한다.
- 다음으로 누산기의 값을 명령어의 간접 주소에 저장하는 경우
  - 주소 소스는 명령어 레지스터로 하고, 이 경우 명령어 레지스터의 주소 부분이 주소 버스에 연결된다.
  - 메모리를 동작시키고, 읽기 모드로 설정한다.
  - 간접 주소 레지스터를 동작시킨다.
  - 클럭 1틱이 지나고, 간접 주소 레지스터에 주소값이 들어간다.
  - 주소 소스를 간접 주소 레지스터로 선택한다.
  - data bus enable 을 1로 설정한다.
  - 메모리를 동작시키고, 쓰기 모드로 설정한다(r/w 값은 0).
  - 프로그램 카운터를 증가시킨다.
- 페치와 실행에 이렇게 여러 단계가 필요하므로, 각 단계를 추적할 카운터가 필요하다.
  - 이 카운터의 내용과 명령어의 명령 코드 및 모드 부분이 제어 신호를 결정한다.
  - 가장 복잡한 연산의 경우 3단계가 필요해서, 카운터는 2비트 카운터여야 한다.
- p187의 회로는 출력에 규칙성이 없을 때가 있는 랜덤 회로이다.
- 한편 제어 장치를 구현할 때 랜덤 논리 대신 적당한 크기의 메모리를 사용할 수도 있다.
  - 카운터 출력과 명령어의 명령 코드와 주소 지정 모드 부분을 메모리 주소에 연결한다.
  - 각각의 19비트 워드의 구성 p188
  - 랜덤 논리 대신 메모리를 사용한 또 다른 상태 기계이자 작은 컴퓨터! 이를 마이크로코드를 썼다고 말한다.
- 마이크로코드는 일반 사용자가 변경할 수는 대개 없고, 제조사가 작성해서 배포한다. 그래서 ROM을 쓰는 경우가 많다.

## RISC와 CISC 명령어 집합
- 유용한 명령어가 많아질수록 컴퓨터는 복잡해지기 마련..
- 그런데 복잡한 명령어 중 대부분은 쓰지 않는다!
  - Swift enum으로 치면, 명령어 하나하나에 case를 할당하는 것.
  - 이를 CISC라고 부른다.
- 반면 복잡한 명령어를 거의 걷어내고, 정 필요하면 대부분 쓰는 단순한 명령어의 조합으로 처리하는 방법이 대두됐다.
  - RISC는 이것을 말하는 것.
  - 적재-저장 구조를 사용하여, 메모리와 레지스터를 오가는 명령어 및 레지스터 간 명령어로만 이루어진다.
- 한편 여담이지만, C에 있는 포인터는 간접 주소 지정을 추상화한 것이다.

## GPU
- 그래픽 처리 장치.
- 그래픽 작업의 특성
  - 일반적으로 CPU가 가진 모든 기능이 필요하진 않다. 
  - 한편 그래픽 특성상 병렬화하기 좋기도 하다. 여러 점을 한 번에 찍으면 좋잖아?
- GPU의 특징
  - 간단한 처리 장치가 매우 많이 들어 있다.
  - 메모리 버스 폭이 더 넓어서, 메모리에 더 빠르게 접근할 수 있다.
  - (그래서 채굴할 때 쓰나)
- 표준 프로그래밍 언어로 GPU를 프로그래밍할 수 있게 하는 각고의 노력 끝에..
  - 구조의 이점을 살릴 수 있는 공학 계산, 인공지능 등에 쓰일 수 있게 됐다.
  - 채굴(!!!)

## 정리
- 컴퓨터를 만들어 봤다.
- 스택이나 메모리 관리 하드웨어 등은 다음 장에서.