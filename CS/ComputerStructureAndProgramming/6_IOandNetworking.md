# 입출력과 네트워킹
- 샘플링! 오오..

## 저수준 I/O
- CPU가 읽거나 쓸 수 있는 비트에 물건을 연결한 형태.
- 결국 읽거나 쓴다는 것은 전기 신호고, 그거에 뭔가 연결하면 물리적 상호작용이 일어날 테니.

### I/O 포트 (p222 그림과 함께)
- 그거 아십니까? LED는 다이오드이면서 빛도 내는 장치라는 거.
- 다이오드는 전기의 방향을 제한한다.
- 저항을 직렬로 연결해 전류의 양 또한 제한할 수 있다. 옴의 법칙을 사용해 구하면 되지렁
  - 이 경우 LED에 흐르기를 원하는 최대 전류는 LED 데이터 시트를 보면 된다.
- 스위치를 통해 전기를 연결하면 LED가 빛날 것이다. 짜잔~ 아주 간단한 I/O 장치!
- AVR PORTB 레지스터는 세 가지 레지스터에 의해 제어된다.
  - DDRB 레지스터는 데이터 방향 레지스터로, 각 핀을 입력으로 쓸 지 출력으로 쓸 지 결정한다.
  - PORTB는 출력 데이터를 저장하는 래치다.
  - PINB는 핀의 값을 읽는다.
- 상기 레지스터는 앞에서 살펴본 디먹스, 플립 플롭, 트라이스테이트 버퍼를 다른 방식으로 배치한 정도다. p223
- DDRB 레지스터의 어느 비트에 1을 넣으면 그 비트 번호에 해당하는 PORTB 비트가 출력에 쓰이게 된다.
  - 0을 넣으면 출력이 아니고 입력에 쓰이게 된다.
- PORTB는 포트의 출력 부분으로, 어느 비트에 0이나 1을 넣으면 핀의 출력 전압이 0이나 1로 바뀐다.
- PINB를 읽으면 연관된 핀의 상태를 알 수 있다.
- p223의 그림에서 6번과 0번 핀을 하이로 올리고 나머지를 로우로 내리면?
  - 01000001, 0x41이 된다.
- 칩에서 데이터를 꺼내거나 데이터를 칩에 넣는 건 쉽다. 
  - PINB7을 보면 스위치 상태를 알 수 있고, PORTB0에 값을 넣으면 LED를 켜거나 끌 수 있다.

### 버튼을 눌러라
- 간단한 푸시 버튼을 통해 눌렀을 때 두 접점을 연결해 보자.
- p224 그림에서, IRQ(인터럽트 요청) 핀에 연결된 저항을 통해 논리 1을 공급한다.
- 스위치를 누르면 회로가 타지 않는 선에서 전류를 제한하며 논리 0을 공급한다. (인터럽트의 발생)
- 버튼을 누르면 바로 접점이 딱 붙는 게 아니고, 보통 금속의 탄성 때문에 살짝 떨어졌다가 다시 붙는다.
  - 이로 인해 의도와 다르게 인터럽트가 여러 번 발생하게 된다.
- 인터럽트 핸들러에 타이머를 설정하고, 그 시간이 지나고서야 비로소 버튼 상태(접점)를 감지한다. 이것이 디바운스!!
  - Reactive Programming에서 사용하는 Debounce와 매우 비슷하다.
- 다만 버튼의 감가상각을 고려했을 때 디바운스도 만능은 아니다.
  - 게다가 모든 주변 장치의 버튼에 일대일 대응 시킬 정도로 핀이 많지도 않을걸.
- 대부분의 시스템에는 주기적으로 인터럽트를 만드는 타이머가 있고, 여기에 얹혀 가면 편하다.
- 타이머 틱을 활용해 여러 버튼을 디바운싱하는 방법으로 FIR(Finite Impulse Response)이 있다. p226
  - 내부 큐를 활용해, 매 틱마다 오래된 값을 버리고 새 값을 추가한다.
  - 이후 배열 원소들을 OR 해서 상태를 만든다.
  - 만들어진 상태는 다른 큐의 current 입력으로 넣고, 원래 있던 current는 previous로 옮긴다.
  - current와 previous를 XOR하면, 어떤 버튼이 상태가 바뀌었는지 알 수 있다.

### 빛이 있으라
- 아무튼 빛이 나오는 컴퓨터 부품. 상태를 표시하던지, 간단한 수치를 표시하던지..
- 엘리베이터에 있는 7 세그먼트 기억하시죠?
  - 이 세그먼트를 처리하려면 16가지 전기적 접점, 핀이 필요하다.
  - 하지만 보통 한 개씩만 연결하고, 핀 하나에는 모든 LED를 함께 연결한다.
  - 공통 캐소드 디스플레이. 모든 캐소드는 한 번에 연결되고, 각 애노드마다 별도의 핀이 배정된다.
- 이러한 디스플레이의 제어를 위해서는 숫자 혹은 문자, 그에 따라 무슨 LED를 켤 지 맵핑하는 표 정도가 필요하다.
- 이러한 디스플레이는 하나만 쓰는 경우는 보통 잘 없다만, 기기 스펙상 충분한 포트를 제공하지 못하곤 한다.
  - 이를 위해 멀티플렉싱을 사용한다. p228
  - 디스플레이 세그먼트가 켜지려면 해당 디스플레이의 애노드가 0이면서 캐소드가 1이어야 한다는 점을 기억하자.
- 디스플레이가 작동하게 하기 위해 인간의 잔상 효과를 이용한다.
  - 1/24초보다 짧은 간격으로 깜박거린다면 켜져 있는 것과 같다.
  - 타이머 인터럽트 핸들러를 사용해 켜져야 하는 디스플레이를 깜박이게 하면 된다.

### 빛, 동작, 그리고 상호 연동
- 버튼과 디스플레이가 함께 있는 장치라면?
- 버튼과 디스플레이 입력을 멀티플렉싱하면 핀을 덜 써도 된다(...).
- p229 전화기의 예시 (간략화된 예시)

### 밝기 조절
- 디스플레이 밝기 조절도 해야 한다면??..
- 가지가지 한다 싶은데, 이 또한 잔상 효과를 이용할 수 있다.
  - 디스플레이가 "깜박이는" 전체 단위 시간을 나누어, 적은 시간 동안 켜져 있으면 어두운 것처럼 보인다(!!)
  - 다만 이것이 리니어하게 비례하는 것은 아니다.

### 그레이의 2^n가지 그림자
- 모터, 바퀴, 노브 같은 회전축의 위치를 알아내야 하는 경우가 있다.
- 이걸 구현하려면 어쨌든 축의 위치를 2진수로 인코딩해야 한다. p230 3비트 인코더
- 그런데 이렇게 피자 모양으로 인코딩된 인코더를 쓴다 해도, 읽어들일 때 발생하는 전파 지연이 있다.
- 그리고 제대로 자로 잰 듯 딱따닥 그려진 인코더가 아닌 경우엔 더 큰 재앙이 발생한다.
- 그래서 그레이 코드로 각도를 표현하게 된다. p231 그레이 코드 로터리 인코더.
  - 그레이 코드는 음.. 내가 보기에는, 하나의 색칠 상태(비트)가 최소 1/4바퀴 동안 지속된다.
  - 이렇게 하면 잘못 그린 것으로 인한 부정확성도 어느 정도 방지할 수 있을 것이다.
  - 또한 하나의 상태가 오래 지속되므로 전파 지연에 의한 영향도 덜 받을 것이다.

### 쿼드러처
- 2비트 그레이 코드를 약간 비틀어서, 어떤 대상의 위치 변화와 방향만 알아야 할 경우 써 먹을 수 있다.
- 이 경우 네 가지 상태가 존재하기 때문에, 쿼드러처(quadrature) 인코딩이라고 부른다.
  - 쿼드러처에서는 2비트 그레이 코드 패턴이 여러 번 반복된다.
  - 2비트 그레이 코드는 시계 방향으로 돌렸을 때 0132의 순서로 코드가 발생한다.
  - 이를 이전 비트와 현재 비트의 합성값을 통해 회전을 감지하는 것이다.
- 쿼드러처 인코더를 90도 엇갈려 놓고 가운데 공을 넣으면? 볼 마우스다(!!!).

### 병렬 통신
- 앞에서 살펴본 LED를 켜는 회로의 확장.
- 포트 B에 8가지 LED를 연결하고 ASCII 코드를 발광하게 할 수 있다(ㅋㅋ).
- 병렬이란 말 자체가 컴포넌트 하나하나에 별도의 선을 두어 동시에 모든 컴포넌트를 제어한단 뜻.
- 그래서 진짜로 병렬 포트에는 아스키 문자 코드를 전송하기 위한 8개의 데이터 선이 존재한다.
- 그리고 올바른 데이터를 감지하기 위해 "지금 데이터를 보낸다" 알려 주는 스트로브 신호가 있다.

### 직렬 통신
- 한 선에 전달될 수 있는 신호의 속도에는 한계가 있고, 병렬 통신은 선이 많이 필요하다.
- 통신 거리가 길어질수록 (전선 가격을 포함한) 통신 비용이 늘어난다.
- 하나의 선에 여러 개의 신호를 보낼 수 있을까?? 있다..
- 시프트 레지스터를 통해 클럭 신호가 각 비트를 한 위치씩 시프트시키고, 그 빈 공간에 선으로 받은 비트를 넣는다.
  - 그런데 이렇게 하면 클럭을 하나만 놓쳐도 데이터 대재앙이 발생할 수가 있다.
  - 그래서 동기화가 필요하다.
  - 하지만 직렬 통신은 아무튼 선을 최대한 덜 쓰는 게 목표다.
- 그래서! 돌아오는 선을 하나 쓰는 걸로 해결했다!
  - 이 선은 아무 일도 없을 때 1, 하이 상태로 유지되며, 0(로우) 상태로 내려가는 것을 스페이스라고 한다.
  - 스페이스 상태로 처음 들어갈 때는 시작 비트라고 불리며, 이 이후 8비트 데이터가 전달된다.
  - 그리고 문자 끝에는 하이 상태인 정지 비트가 2개 붙는다.
- 위와 같은 기법을 시분할 멀티플렉싱이라고 하며, 시프트 레지스터 대신 셀렉터를 활용해 구현할 수 있다.
- "초당 비트 수"는 보 레이트라고도 불린다.
- 한편 반이중 연결을 통해, 송신자와 수신자 중 어느 순간에는 한 쪽만 말할 수 있다.
  - 그래서 "알아들었다" 라는 것을 표현하기 위해 "오버"라는 말을 쓰게 됐다!!!
- 전이중 연결은 반이중 연결과 달리 둘이 동시에 다른 방향으로 통신이 가능하다.
- 이런 통신을 가능하게 해 주는 회로가 하나의 IC로 발명되었고, 이를 UART라고 한다.
  - 또한 이를 소프트웨어로 구현하면 비트 뱅잉이라고 한다.

### 파동에 올라타라
- 마크-스페이스 방식의 신호는 아무튼 전화선에선 제대로 작동하지 않는다.
- 이 문제를 라디오에서 사용한 방식으로 해결할 수 있었다. ? 일단 더 살펴보자.
- 일단 사인파를 꺼내 오자. 사인파는 다른 모든 파형의 원형이다.
- 파장 == (매질에서 파동의 속도) / (주파수)
  - 주파수는 매초 같은 방향으로 0을 지나치는 횟수
  - 파장은 같은 방향으로 0을 지나는 연속된 두 지점 사이의 거리
- 여러 파장은 각기 다른 특성을 가지고 있다는 것을 짐작할 수 있다.
- 이 중 알맞는 파동을 반송파, 혹은 캐리어로 삼아 올라타자.
  - 이 캐리어를 마크-스페이스 파형과 비슷하게 바꾸는 변조를 하고 싶다.
  - AT&T가 만든 주파수 편이 변조! (p.238)
    - 마크-스페이스 신호에 의해 주파수가 바뀐다.
    - 아스키 문자 A라면 높은 소리-낮은 소리(일정)-높은 소리 방식으로 전달되었을 것
  - 이러면 받는 쪽에서는 소리를 마크와 스페이스로 되돌려야 하며, 이를 복조라고 한다.
  - 변조와 복조를 수행하는 장치를 모뎀이라고 한다.
  - 옛날 전화기에서 삐이익 삒삑 하는 소리가 난다면 모뎀이 내는 소리인 것..

### 범용 직렬 버스
- USB는 흔히 쓰이니까 보고 들어가자..
- 4줄짜리 선을 가진 단일 커넥터!!
  - 두 줄의 전력선과 하나의 연선.. 으로 시작했다.. 지금은 24줄짜리도 있음.
- USB는 데이터를 패킷으로 나누어 전달한다. 패킷은 헤더와 페이로드가 있다.
- USB는 음향과 비디오를 등시성 전송할 수 있다.
- 종단점은 데이터 전송의 보장을 위해 원하는 대역폭을 예약해달라고 컨트롤러에 요청할 수 있다.

## 네트워킹
- 랜(근거리 네트워크)과 왠(광역 네트워크)의 두 가지가 있다.
- 전신/전화 시절의 네트워크는 인터넷이 아니었다! 회선 교환 방식의 전화 네트워크.
  - 이 경우 실제로 선이 연결되어 회로를 만들었다.
  - 교환국이 그냥 있던 게 아닌 셈.. 스위치를 통해 이런 걸 수행했다.
- 지금의 전화는 패킷 교환 방식을 사용한다.
- 초기 컴퓨터 네트워크는 전화 네트워크와 모뎀을 활용해 각 지점 사이 통신을 하는 반자동 지상 환경의 일부였다.
- LAN을 이용한 실험이 60년대 말부터 많이 있었다.
  - 하지만 랜과 랜을 연결할 방법은 없었고, 모뎀과 전화선으로 광역 통신을 했다.
- ARPANET은 패킷 스위치 방식의 WAN으로, 인터넷의 원형이 되었다.
  - 즉 인터넷은 여러 LAN을 하나로 연결하는 WAN이다.

### 최근의 LAN들
- 제록스 팔로 알토 연구소에서 개발된 수많은 기술들!
- 최초의 이더넷은 반이중 시스템이었으며, 모든 장치가 같은 선에 연결됐다.
- 각 장치의 네트워크 인터페이스에는 맥 주소가 부여됐고, 데이터는 1500여 바이트의 프레임으로 구성됐다.
- 어떤 한 장치가 브로드캐스팅하면, 자기를 대상으로 한 게 아니란 걸 아는 장치는 이를 무시한다.
  - 그런데 둘 이상의 장치가 동시에 브로드캐스팅하려 한다면?
  - 이를 해결하기 위한 랜덤 백오프 수 재시도.
- 요즘 이더넷은 반이중 방식은 아니고, 각 장치가 라우터에 연결되어 패킷이 정확히 배달된다.

### 인터넷
- 물리적인 네트워크는 아니다.
- 오히려 여러 계층으로 이루어진 프로토콜의 집합이다.
  - 아래로 갈 수록 물리적인 네트워크와 가까우며, 위쪽 네트워크에 영향을 끼치지 않도록 디자인되었다.
  - 그래서 앞으로 신기술이 나와도 "인터넷"의 작동엔 문제가 없는 것.

#### TCP/IP
- 인터넷이 사용하는 두 가지 프로토콜.
- IP는 패킷(데이터그램)의 전송을 담당하며, 컴퓨터를 위한 전신과 같다.
- TCP는 패킷의 전달을 보장한다.

#### IP 주소
- 인터넷상의 컴퓨터의 주소.
- 하드웨어에 묶여 있진 않아서 변경될 수도 있다.
- 대부분 IPv4를 사용한다. 그러나 충분하진 않고, 점점 IPv6로 나아가고 있다.

#### 도메인 이름 시스템
- DNS!
- 이름을 주소로 바꿔 준다

#### 월드 와이드 웹
- TCP/IP 위에 구현된 프로토콜 중 가장 많이 쓰이는 것은 HTTP(HyperText Transfer Protocol)다.
- 하이퍼텍스트.. 는 사실 그냥 링크가 붙은 텍스트다.
- HTTP 표준은 웹 브라우저가 웹 서버와 상호작용하는 법을 정의한다.
  - URL을 브라우저에 입력하면 웹 페이지를 얻을 수 있다.
  - URL에는 도메인 이름과 경로가 포함된다.
- 웹 페이지는 보통 HTML로서 존재한다.

## 아날로그 처리 방법
- 실제 소리나 빛은 연속적이지만 컴퓨터는 연속적인 대상을 저장할 방법이 없다.
- 따라서 샘플링을 해 줘야 한다.
  - 시간이나 공간상 일정한 간격으로 값을 읽어들여야 한다는 뜻.
- 그리고 이걸 다시 보여주려면 샘플링 데이터로부터 연속적인 신호를 다시 만들어야 한다.
- 샘플링을 다루는 분야가 바로 이산 수학.

### 디지털을 아날로그로 변환
- DAC를 만들면 된다. (...)
- LED 8개를 사용해서 9가지 상태를 만드는 것부터 시작할까.
- 하지만 8비트로 9가지 수준은 좀 비효율적이다. 8비트로 256가지 수준을 만들어 보자.
  - 그렇게 한다면 필요한 LED 갯수는 엄청나게 많아진다.
  - 대략 레벨 1보다 레벨 2가 2배 밝고, 레벨 3은 4배 밝고, ... 그런 식.
- 실제 DAC는 빛 대신 전압을 만들어낸다. DAC가 만들어 내는 레벨 수를 해상도라고 말한다.
  - 정확히는 DAC가 만들어낼 수 있는 최대 전압을 단계 수로 나눈 값.
  - 10비트 DAC가 최대 5V를 만들어낼 수 있다면, 해상도는 대략 0.005V
- DAC를 활용하면 아날로그 파형을 만들 수 있으며, 오디오 플레이어나 신스가 이런 식으로 작동한다.
- DAC 입력을 일정 비율로 변경하면 파형을 만들 수 있다.
  - 8비트 DAC를 포트 B에 연결하면 sawtooth 파형을 만들 수 있다.
- 더 복잡한 파형을 만들기 위한 장치에는 데이터를 써넣기 위한 메모리가 들어 있는 경우가 많다.
  - 그럼 추가 회로를 통해 메모리에 있는 데이터를 읽겠제.
  - CPU가 처리하는 다른 작업과 무관하게 일정 비율로 읽어들여 처리하기 위해 FIFO 설정을 만들어 쓴다.
- 워터마크는 FIFO 메모리와 관련된 트리거 역할을 한다.
  - 낮은 워터마크는 메모리가 거의 빌 때 인터럽트를 발생시킨다.
  - 높은 워터마크는 vice-versa
- 고수준 소프트웨어에서는 이를 활용해 일정 비율로 연속적으로 출력이 일어나도록 메모리를 채울 수 있다.

### 아날로그를 디지털로 변환
- ADC는 DAC보다 좀 더 복잡하다.
- 먼저 아날로그 신호의 현재 값을 흔들리지 않게 안정적으로 잡아낸다.
  - 샘플 앤 홀드라는 회로를 사용해 아날로그 파형의 값을 잡아낼 수 있다.
  - 디지털 홀드의 아날로그 버전.. 정도?
  - 스위치를 닫아서 샘플을 얻으면 아날로그 신호의 현재 값이 저장 탱크에 저장된다.
  - 저장 탱크에 있는 값은 안정적이고, 이를 측정해 디지털 값을 만들어낸다.
- 값의 기준은 어떻게 가냐? "비교기"라는 것이 있다. threshold 전압값이 있다.
- 비교기를 여러 기준 전압과 연결해 쌓으면 플래시 변환기를 만들 수 있다.
  - 플래시 변환기는 비트-효율적이진 못하다.
  - 기준 전압을 변화시킬 수 있다면 비교기를 하나만 써도 되지 않을까?
  - 이 기준 전압은 DAC에서 얻을 수 있다!!
- 저장 탱크에서 나온 샘플값을 DAC의 값과 비교하기 위해 비교기를 사용하는 회로가 있다. p250
  - Clear가 활성화되면 두 값을 비교하고, 같아지면 DAC 출력이 0이 되면서 카운터가 비활성화된다.
  - 원하는 값을 얻을 때까지만 카운터가 활성화되어 있는 것!
  - DAC 출력이 경사로를 올라가듯 차차 늘어난다고 하여, 이를 램프 변환기라고 한다.
  - 보면 알다시피, 샘플 크기에 비례하는 시간이 걸린다는 단점이 있다. (n이 ADC 비트 수일 때 최대 2^n클럭)
- 램프 변환기의 단점을 우회하기 위해 연속 추정 변환기를 사용하여, 이진 탐색을 수행한다.
  - 이진 탐색으로 찾고자 하는 것은 샘플의 크기이며, 배열의 크기는 ADC의 비트 수!

### 디지털 오디오
- 샘플링으로 오디오를 디지털화시킨다는 것은, 일정 시간 간격으로 신호의 진폭을 측정한다는 것.
- 일정한 샘플링 주파수로 스퀘어를 얻을 수 있으며, 상승 에지마다 ADC를 활용해 높이를 기록할 수 있다.
- 샘플이 있다면 이를 DAC에 공급해 원래의 신호를 재구성할 수 있다.
- 파형이 대단히 왜곡된다면, 샘플을 더 많이 만들어 보자.
- 그런데 사실 어떤 파형이든 사인파의 가중치 합을 통해 나타낼 수 있다.
  - 가령 사인으로 스퀘어를 만들려면 기음과 홀수 배음을 더하면 되는 것처럼.
  - 이것이 푸리에 변환이다.
- 푸리에 변환을 활용하면 주파수에 따른 진폭을 그래프로 그릴 수 있다.
  - 지금까진 시간에 따른 진폭을 표현했는데, 꽤 새로운 관점이 아닐 수 없다.
  - 스펙트럼 분석기가 바로 이를 응용한다.
  - 컴퓨터에서는 FFT를 알고리즘을 통해 이를 쉽게 구현할 수 있다.
- 미디어 플레이어에서 나오는 그래픽 이퀄라이저는, 조절 가능한 필터의 집합이다.
- 필터는 말하자면 전이 함수의 주파수 버전. 
  - 로우 패스와 하이 패스가 있다.
  - 조합하면 밴드 패스나 노치를 만들 수 있다.
  - 필터 엣지가 날카롭지 않은 것은 롤 오프이다.
  - 버튼 디바운서는 사실 로우 패스 필터다!
- 필터를 적용하는 것은 두 곡선을 곱하는 것의 효과가 있다.
- 필터를 잘 적용하면, 위쪽에서 발생했던 샘플 딴 소리의 왜곡을 없앨 수 있다!
- 단, 신호를 제대로 잡아내기 위해서는 최고 주파수의 2배 이상의 비율로 샘플을 얻어야 한다. (나이퀴스트 비율)
- 사람의 가청 주파수는 20-20000Hz 정도이므로, 40kHz 정도의 샘플 레이트로 모든 소리를 잡아낼 수 있다!
- 그런데 만약 21kHz 신호를 40kHz의 샘플 레이트로 잡아낸다면? 
  - 일종의 가짜 신호인 에일리어스가 나타난다. 폴딩이나 에일리어싱 현상이라고 한다.
  - 이를 피하기 위해 로우 패스 필터를 넣어야 한다.
- 표준 오디오 샘플링 레이트는 40kHz보다 훨씬 큰 경우도 있다.
  - 44.1, 48, 96, 192, ...
  - 데이터 낭비 아니예요? 당연히 아니니까 쓴다.
- 이는 위상과 관련이 있다.
  - 나이키스트 비율로는 위상은 재구성할 수 없다.
  - 위상차는 좌우 귀에 도달하는 신호 사이의 시간차로 인해 발생하며, 이로 인해 사람은 공간을 인식한다.
  - 파장이 긴 소리는 상대적으로 위상에 따른 차이가 덜하다.
- 스테레오 사운드를 듣는다면 양쪽의 소리의 위상차로 안해 이미지가 느껴진다.
- 위상이 정확하지 않으면 이미지가 탁해진다.
- 따라서 더 나은 위상과 스테레오 이미지를 위해 높은 샘플링 레이트가 정당화될 수 있다.
- 오디오에는 보다시피 많은 데이터가 있고 이를 압축할 수 있다면 좋을 것이다.
  - 무손실 압축과 손실 압축이 있다.
  - 무손실 압축은 최대 절반 정도만 줄어든다. FLAC
  - 손실 압축은 음향심리학의 원리를 사용해 작동한다.

### 디지털 이미지
- 2차원 공간을 샘플링해 픽셀에 뿌려야 한다.
- 각 픽셀은 RGB로 표현되며, 각 색에 8비트를 사용한다.
- 컴퓨터는 가산 혼합 색 시스템(RGB)을 사용해 색을 표현한다. 
  - 인쇄에 쓰이는 감산(CMYK)과는 좀 다르다.
- 포인트 샘플링을 통해 색을 기록한다.
  - 사각형의 중심점의 색상을 기록하는 방법!
- 여기서도 필터링을 할 수 있는데, 슈퍼샘플링을 통해 사각형 내 여러 점의 색상의 평균을 내는 방법이 있다.
- 이것도 압축을 할 수 있다. JPEG 손실 압축.
  - 뇌는 색상 변화보다 밝기 변화에 민감하다는 사실을 응용.

### 비디오
- 또 한 차원 높아져서 시간 간격으로 2차원의 이미지를 나열.
- 대개 이미지 샘플링과 비슷하다.
- 비디오 압축에 응용되는 원리로는, 사실 프레임 전체가 변화되는 경우는 거의 없다는 것에 착안하는 것.
  - 변경된 영역의 데이터만 필요한 거다!!
  - 단, 데이터가 간혹 왜곡된다. 원본이 깨진 경우.
  - 데이터에 키프레임이라는 완전한 이미지를 추가함으로써 이를 해결한다.
- 프레임 사이의 차이를 감지하는 알고리즘은 복잡하다. 그래서 새 압축 표준은 레이어링을 지원한다.
  - 레이어 간에 각기 다른 그림을 중첩시켜 비디오 이미지를 만들어낼 수 있다.

## 휴먼 인터페이스 장치
- 사람이 컴퓨터와 소통하는 방법.

### 터미널
- 배치 프로세싱: 천공 카드를 순서대로 넣어 프로그램 실행
- 텔레타이프에 컴퓨터를 연결할 때, 텔레타이프는 선의 끝에 연결됐기 때문에 터미널이라고 불렸다.
- 이후 시분할 시스템이 생겼고, OS가 이 작업을 컨트롤하게 됐다.
  - 스래싱의 위험!
  - 시분할 시스템은 멀티태스킹 시스템이다. 마치 호텔 방과도 같지. 내가 쓸 때만 내 방이다.
  - 작업의 소속을 구분하기 위해 사용자 개념이 생겨났다.
- 이 때의 터미널이란, 아무튼 뭔가 종이 같은 걸로 된 걸 뽑아내는 것.

### 그래픽 터미널
- 화면을 활용한 터미널! 사실 그냥 화면에 표시되는 모든 정보라고 봐도 무방하다.
- 초기에는 글자만 표시할 수 있었다. 1920개 정도?
- 나중엔 더 많은 걸 할 수 있게 됐고 이런 기능은 ANSI X3.64로 표준화되었다.

### 벡터 그래픽
- 화면이 인치당 표시할 수 있는 좌표 위치의 개수가 해상도. 
- 벡터 그래픽은 선 또는 벡터로 그림을 그리는 방식. 밝기와 이동 등의 방식을 활용해 구현되었다.
- 처음부터 다시 시작 명령어도 있는데, CRT 인광 물질의 지속성과 관련이 있다.
  - 사람의 눈은 그거보다 느리니까 괜찮지만..
  - 방사파로 인해 그림이 흔들려 보일 수도 있다.
  - 디스플레이 목록이 길어지면 초당 60번 화면을 못 그릴 수 있다. (플리커)

### 래스터 그래픽
- p269 그림처럼, 지그재그로 소스 조지듯 조지는 방식.
- 수평 리트레이스로 다음 줄을 그리고, 수직 리트레이스를 통해 처음으로 돌아간다.
- 이를 구현하기 위해서는 정확한 시간에 밝기를 정확하게 조정하기만 하면 된다.
- 점과 점 사이에 그림은 그릴 수가 없어서, 모서리 계단 같은 현상이 발생하곤 했다.
  - 해상도가 썩 좋진 않아서 언더샘플링과 에일리어싱이 발생한 것.
  - 요즘의 컴퓨터는 슈퍼샘플링을 활용한 안티 에일리어싱이 적용되어 있다.
- 래스터 스캔은 팩스, 프린터, 스캐너 등에도 사용한다.
- 컬러 디스플레이의 경우 래스터의 각 지점마다 RGB의 점을 표현할 수 있어야 한다.
  - 3개의 전자 빔을 세 점에 정확히 맞추기

### 키보드와 마우스
- 터미널은 아무튼 입력도 받아야겠지!
- 키보드는 여러 스위치와 논리 회로의 묶음이다. 격자상에 놓고 멀티플렉싱한다. 각 열의 입력을 읽는다.