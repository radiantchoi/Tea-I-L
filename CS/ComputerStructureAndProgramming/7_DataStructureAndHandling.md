# 데이터 구조와 처리
- 지금까지 본 메모리 시스템의 특성을 염두에 두고 데이터를 조직적으로 잘 정리하면 성능이 좋아진다.
- 이번 장 한줄요약: "**참조 지역성**"
  - 서로 필요한 데이터를 가까이 붙여 놔라
  - 금방 사용할 데이터는 가까운 곳에 저장하라

## 기본 데이터 타입
- 크기(비트 수)와 해석(부호 유무)이라는 두 가지 측면이 존재한다.
- C 기준으로 char, short, long, long long, unsigned ~~, float, double, int, ...
- 앗, 그런데 포인터라는 게 있다.
  - 컴퓨터 아키텍처에 따라 결정되는 크기의, 부호가 없는 정수
  - 해당 아키텍처의 워드 크기와 보통 같다.
  - 간접 주소 지정이 포인터 개념이다.
- 일부 언어는 포인터의 오용을 막기 위해 참조라는 더 추상적인 개념을 구현하기도 한다.

## 배열
- 기본 타입이 집이라면 배열은 아파트
- 각각의 호수는 인덱스라고 부를 수 있고, 각각의 집은 원소라고 부를 수 있다.
- 각 원소는 0번째 주소인 기저 주소로부터의 offset으로 지정할 수도 있다.
- 다차원 배열도 있다.
- 참조 지역성은 다차원 배열에서 관건이 된다!
  - 행 우선으로 배열을 저장한다.
  - 순회도 같은 행부터 하는 것이 훨씬 성능이 좋겠지.
- 한편 Index out of range 또한 항상 주의해야 한다.

## 비트맵
- 큰 데이터를 표현하고 싶을 때 비트의 배열인 비트맵을 활용할 수 있다.
- 예를 들면 8비트를 5줄 늘어놓으면 35비트의 큰 데이터도 담을 수 있다.
- 비트맵에 대해 수행할 수 있는 기본 연산
  - 비트 설정하기(set, 1로 만들기)
  - 비트 지우기(clear, 0으로 만들기)
  - 비트가 1인지 검사하기
  - 비트가 0인지 검사하기
- 8로 나누기를 통해 특정 비트가 들어 있는 바이트를 찾을 수 있다.
  - 비트 번호 17이면, 17/8 == 2
- 비트 위치에 대한 마스크를 만들어야 한다.
  - 비트 위치와 0x07을 AND하여 하위 3비트를 얻는다.
    - 비트 번호 17이면, 00010001 AND 00000111 = 00000001
  - 앞에서 얻은 1만큼 1(00000001)을 왼쪽으로 시프트하면 마스크가 된다.
    - 1을 1만큼 왼쪽으로 시프트하면 00000010.
    - 2번 바이트에서 어디를 봐야 하는지를 이를 통해 알 수 있다.
- 인덱스와 마스크를 활용해 기본 연산을 쉽게 할 수 있다.
  - set: 비트들 = 비트들 OR 마스크
  - clear: 비트들 = 비트들 AND (NOT 마스크)
  - 1인지 검사: (비트들 AND 마스크) != 0
  - 0인지 검사: (비트들 AND 마스크) == 0
- 자원의 사용 가능 여부를 나타낼 때도 비트맵이 유용하다.

## 문자열
- 여러 문자로 이뤄진 시퀀스.
- 문자열 길이가 필요하기 때문에, 문자열 데이터 안에 문자열 길이를 잘 욱여 넣는다.
- 문자열 안에 길이 저장하기! 단 이 경우 문자열 길이가 255자로 제한된다.
- C에서 사용한 방법은, 1차원 바이트 배열로 문자열을 표현하고, 맨 끝에 NUL 문자를 넣는다는 것.
  - 그래서 글자 수 + 1바이트가 문장의 바이트 수가 된다.
  - 한편 그래서 C에서 1바이트를 나타내는 단위는 char가 됐다.
  - 문자열 길이 연산에 O(N) 시간이 걸린다는 점과, NUL 문자를 자유롭게 쓰지 못한다는 것은 단점.

## 복합 데이터 타입
- struct라고 이해하면 쉽다.
- 구조체 안에 있는 것들을 멤버라고 한다. 프로퍼티라고 많이 했었지?
- 복잡한 데이터는 단순한 데이터의 모임인데, 이를 마치 네이티브 타입처럼 쓸 수 있게 하는 문법적 설탕!
- 프로그래밍 언어는 대개 멤버의 순서를 지키고자 하는데, 메모리 정렬도 지켜야 한다.
- 따라서 메모리 프레임 안에 다 안 담길 것 같은 멤버는 다음 줄로 빼 버리고, 사이에 패딩을 넣는다(!!!).
  - 그러니까 각 자료형의 크기를 아는 것이 성능 좋은 구조체를 만드는 데 도움이 된다는 말이렷다.
- Union.. 은 일단 알아만 두자.

## 단일 연결 리스트
- 데이터의 양이 정해져 있지 않은 경우는 배열이 적합하지 않다.
  - 배열의 복사 및 메모리 추가 할당 이슈
  - 미리 충분하게 메모리를 할당하면 낭비가 심함
  - 중간의 원소 삭제시 발생하는 복사
- 이럴 때를 위한 Linked List.
- 다음 아이템을 가리키는 포인터와 데이터 타입, 두 가지 멤버를 가진 구조체로 구현할 수 있다.
  - (책에 구조체라고 써 있다니께? C 구조체 개념인 듯)
- 리스트의 맨 앞은 머리(Head), 마지막은 꼬리(Tail)다.
  - 테일의 경우 next가 null이라 알아볼 수 있다.
- 리스트는 메모리에서 굳이 연속된 위치에 있지 않다.
- 삽입은 헤드 앞에 새 원소를 위치시키면 된다.
- 삭제는 삭제할 원소의 바로 앞 원소의 next가 삭제할 원소의 next를 가리키게 해야 한다.
- 이중 간접 주소 지정을 통한 리스트 아이템의 삭제 p.286

## 동적 메모리 할당
- 새 노드를 위한 메모리 할당은 어디서 할까용
- 런타임 라이브러리가 메모리 관리 장치에게 요청한다.
- 배열 등의 변수가 사용하는 메모리는 정적이나, 리스트 노드는 동적이다.
- 이런 동적인 대상이 사용할 메모리는 힙에서 온다.
- C의 malloc과 free를 활용하자.
  - malloc도 연결 리스트로 구현된 부분이 있다는 게 흥미로운 부분.
  - 크기와, 다음 블록에 대한 포인터를 갖고 있다.
  - 메모리 요청을 받으면 충분한 크기의 메모리를 찾을 동안 순회하고, 할당한 메모리를 리스트에도 반영한다.
  - free하면 다시 연결 리스트에 추가되겠지.
- malloc은 종종 인접한 두 가용 블록을 합친다. 파편화를 막기 위한 것이겠다..
- 할당받은 메모리 경계의 밖에 데이터를 쓰면 size와 next 필드를 오염시킬 수 있다. 잠재적 버그의 원인..

## 더 효율적인 메모리 할당
- 문자열 연결 리스트라고 할 때, 리스트에 드는 메모리와 문자열에 드는 메모리를 모두 받아야 한다.
- 이 경우 노드와 문자열의 크기를 합하고, 메모리 경계를 지키기 위한 패딩을 추가한 크기의 공간을 한 번에 할당.
- malloc뿐만 아니라 free도 이 경우 한 번만 일하면 되니까.

## 가비지 컬렉션
- 포인터는 단지 메모리 주소를 나타내는 숫자일 뿐.
  - 하지만 모든 숫자가 유효한 주소를 나타내는 것은 아니다.
- malloc이나 free를 수동으로 하지 않아도 되는 언어는 대개 Garbage Collection 구현이 돼 있다.
- 자바가 대표적인데, 포인터 대신 참조를 사용한다.
- 그리고 언어의 런타임 환경이 변수 사용을 추적해 더 이상 사용하지 않는 메모리를 자동으로 해제한다.
- 자동 해제 구현법은 다양한데, reference counting 또한 하나의 방법이다.
- 가비지 컬렉션은 프로그래머가 제어할 수 없어, 중요한 태스크를 할 때 갑자기 돌아서 리소스를 쓸 수 있다.

## 이중 연결 리스트
- 단일 연결 리스트의 삭제는 꽤 느리다.
- 이중 연결 리스트는 next 말고 previous 참조도 들어 있다.
  - 메모리 공간과 시간의 트레이드 오프랄까..

## 계층적 데이터 구조
- 이진 트리
  - 트리의 루트는 연결 리스트의 헤드
- 이진 트리는 어떤 값을 찾기는 쉽다.
  - 다만 트리 구성은 노드의 삽입 순서에 따라 달라진다.
  - Unbalanced Binary Tree
- 트리 균형을 잡아주는 알고리즘은 꽤 많다.
  - 삽입/삭제 시 매번 균형을 잡아야 하기 때문에 마찬가지로 일종의 트레이드 오프다.
  - 하지만 트리가 커질수록 부가 비용은 점점 사소해진다.

## 대용량 저장장치
- 디스크의 기본 단위는 블록이고, 연속적인 블록은 클러스터이다.
- 데이터를 블록에 나눠 담을 때, 적합한 블록을 찾으려면 어떻게 할까?
- 대용량 디스크에서 이를 찾기엔 연결 리스트는 이를 찾기엔 너무 오래 걸린다.
- 데이터를 디스크에 저장하려면 영구적인 뭔가가 필요한데, 바로 그것이 파일 이름이다.
- 그럼 파일 이름을 저장할 방법과, 파일 이름과 디스크 블록을 연결할 수단이 필요하다.
- UNIX에서 블록의 일부를 I-Node로 지정한다.
  - 인덱스 + 노드의 합성어.
  - 파일에 대한 여러 정보가 들어간다.
    - 파일 이름, 소유자, 크기, 권한 내역
    - 파일의 데이터가 들어 있는 블록의 인덱스
  - 직접 블록 포인터 12개로, 4096 * 12 바이트까지 데이터를 보관하고, 그 이상은 간접 블록을 사용한다.
  - 간접 블록으로는 최대 4MiB
  - 이중 간접 블록으로는 최대 4GiB, 삼중으로는 4PiB까지 저장이 된다.
- 아이노드 정보에는 블록에 데이터가 있는지 디렉토리가 있는지 표시하는 것도 있다.
  - 사실 유닉스에서 디렉토리는 파일의 한 종류에 불과하다!
  - 디렉토리는 다른 디렉토리를 참조할 수 있고, 이것이 우리가 아는 계층적 파일 시스템이다.
- 링크로 인해 같은 파일이 여러 디렉토리에 나타날 수 있기 때문에, 엄밀히 말하면 아이노드는 트리는 아니다.
- 심볼릭 링크를 통해 디렉토리 링크
- 파일 시스템 그래프 무한 루프를 막기 위한 특별한 코드
- 까지~ 더했는데, 가용 공간을 추적하는 효율적인 방법이 아직 없을 때.
  - 비트맵을 활용하면 되지 않을까? 특히 64비트 워드가 사용가능할 때.
    - 모든 비트가 1이지는 않은 비트맵을 찾는다면 저장 공간을 쉽게 알 수 있다!
    - 그러나 이 방법은 비트맵과 파일 시스템 그래프가 동기화가 깨질 수 있다는 문제가 있다.
    - 데이터를 쓰다가 갑자기 전원이 나가면 아이노드를 사람이 직접 열어 수리해야 하는..
  - 요즘은 저널링 파일 시스템이 이를 보완하기 위해 쓰인다.

## 데이터베이스
- 이진 트리는 데이터를 메모리에 저장할 때 자체는 좋은데, 메모리 안에 못 들어가는 큰 데이터를 넣기엔 별로다.
  - 보통 트리 노드는 크기가 작기 때문.
- 데이터베이스는 정해진 방식으로 조직화된 데이터 모음이다.
  - DBMS에 의해 관리된다.
  - B 트리를 활용한 시스템이다.
  - B 트리는 이진 트리보다 더 많은 자식을 가지며, 브랜치의 수는 디스크 블록 하나를 꽉 채울 만큼이다.
  - 크기가 넘치면 각 노드의 담당 범위를 조정함으로써 균형을 다시 잡을 수 있다.

## 인덱스
- 저장된 데이터에 접근하는 기준.
- 검색하기 훨씬 용이해지지만, 유지보수가 필요하다.
  - 데이터가 바뀔 때마다 모든 인덱스를 갱신해야 한다.

## 데이터 이동
- 어떻게 효율적으로 해 볼까?
- length 바이트 만큼의 메모리를 0으로 설정하고자 할 때.
  - 바이트마다 순회하기
  - 루프 언롤링 기법을 사용하여, 한 번에 여러 개의 순회를 진행하기
    - 그러나 무턱대고 펼친다고 무조건 좋은 건 아니고, 펼친 코드가 캐시 안에 유지될 만큼의 크기여야
  - 더프의 장치는 8회 언롤링한다.
- 한편 64비트 장치라면 한꺼번에 8바이트를 0으로 만들 수 있다는 걸 활용할 수 있다.
  - 물론 남는 바이트나 블록 맨 앞을 처리하는 코드 추가가 필요하다.
- 원본과 복사본의 메모리 경계가 다를 수 있기 때문에 (대부분 같지만) 검사도 해 봐야 한다.
- 영역이 겹칠 때 덮어쓰기 이슈도 조심해야 한다. 역방향 복사를 해야 할 수도?

## 벡터를 사용한 I/O
- 복사를 아예 피할 수 있다면..!
- 데이터 프레임을 이루는 각 부분을 별도로 기록하되, 프레임의 각 부분을 가리키는 포인터의 집합을 시스템에 전달!
  - 이러면 시스템이 오디오를 오디오 장치에 쓸 때 효율적이다.
  - 크기와 포인터들로 이루어진 벡터를 OS에 넘긴다는 게 핵심 아이디어다.
- 벡터로 데이터를 쓰는 행위는 "수집", 읽는 행위는 "분산"이라고 한다.

## 객체 지향의 함정
- 객체와 관련된 부가 비용이 무시할 수 없으며
- 성능이 결정적으로 중요하다면 객체 대신 배열을 활용하라.. 라는 것.

## 정렬
- 정렬 알고리즘이나 잘 만들어진 정렬 함수는 다른 곳에서 참조.
- 정렬 대상이 포인터보다 크다면 데이터 직접 정렬 말고 포인터만 정렬하는 게 나을지도.
- C의 qsort는 정작 데이터 비교는 할 줄 모른다! 비교를 위한 함수 포인터를 내장하고 있다.

## 해시
- 해시의 장점은 잘 아니까 넘어가고
- 해시 함수로 인해 생성되는 값은 메모리 크기보다 작은 범위의 값이어야 한다.
- 해시 함수의 결과를 배열 인덱스로 사용하는 것이 해시 테이블이다.
- 좋은 해시 함수는 계산하기 쉬우면서 키를 골고루 버킷에 뿌려야 한다.
- 해시 충돌은 해시 성능의 저하를 불러온다.
- 해시 체인을 활용해 이 문제를 해결할 수 있다. 해시 버킷을 연결 리스트로 만드는 것.
  - 오픈 어드레싱, 세퍼릿 체이닝을 기억하자!
- 해시 테이블 확장을 통해 해시 자체를 그냥 키울 수도 있다.

## 효율성과 성능
- 효율적인 검색 알고리즘을 위한 여정.. 컴퓨터가 비싸던 시절엔 성능이 곧 효율성이었다.
- 현대는 좀 다르긴 하다. 성능과 효율이 좀 별개.
- 샤딩 혹은 수평 파티셔닝이 좋은 예시이다.
  - 데이터베이스를 각각 다른 기계에서 실행되는 여러 샤드로 나눈다.
  - 요청을 모든 샤드에 날리면 컨트롤러가 결과를 하나로 모으고 반환한다.
  - 이를 통해 병렬적으로 작업을 수행할 수 있다.
- 샤딩의 변종으로 맵리듀스도 있는데, 컨트롤러가 중간 결과를 모으는 방법을 코드로 직접 작성 가능하게 해 준다.