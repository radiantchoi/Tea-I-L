# 컴퓨터 아키텍처와 운영체제
- 컴퓨터의 여러 구성요소를 배치하는 방법.
- 여기서 다룰 것은 특히 메모리와 관련된 구조 개선.
- 여러 프로그래밍을 실행하는 멀티태스킹, 그것을 감독하는 운영체제 등

## 기본적인 구조 요소들
- 폰 노이만 구조와 하버드 구조
- 사실 두 구조의 유일한 차이는 메모리 배열 뿐.
- 폰 노이만 구조가 조금 느린데, 명령어와 데이터를 가져올 수가 없기 때문이다. (데이터 버스와 주소 버스가 하나뿐)
- 한편 하버드 구조는 두 가지의 메모리를 쓰기 때문에 이를 위한 버스가 더 필요하다.

### 프로세서 코어
- 4장에서 본 것처럼, CPU는 ALU, 레지스터, 실행 장치의 조합이다.
- 더 좋은 성능을 위한 멀티프로세서 시스템이 1980년대에 처음 등장했다.
- 하지만 여러 CPU를 활용할 수 있도록 프로그램을 병렬화하는 문제는 일반적인 경우 할 수 없다.
- 소형화와 집적화가 일어난 결과, 이전에 CPU라고 부르던 것을 요즘은 프로세서 코어라고 부른다.

### 마이크로프로세서와 마이크로컴퓨터
- 메모리와 I/O가 프로세서 코어와 같은 패키지에 들어 있지 않으면 마이크로프로세서
- 모든 구성요소를 한 칩 안에 넣어 두면 마이크로컴퓨터
- 상기 두 용어는 모호하게 사용되는 감이 있다.
- 칩 안에서 메모리가 차지하는 영역이 크기 때문에 일반적으로 마이크로컴퓨터는 마이크로프로세서보다 덜 강력하다.
- 마이크로프로세서는 큰 시스템의 부품으로 쓰이고, 마이크로컴퓨터는 식세기 등에서 찾을 수 있다.
- SoC라고 부르는 변형도 존재한다.

## 프로시저, 서브루틴, 함수
- 코드 반복을 피하고자 하는 게발자(게으른 개발자ㅎ)
- 사실 꼭 게을러서 그런 건 아니고..
  - 메모리를 덜 차지한다.
  - 버그가 있을 경우 한 군데만 고치면 된다.
- 함수(aka 프로시저, 서브루틴)는 코드 재사용을 위한 주요 수단이다.
  - 함수의 정의와 호출을 통해 같은 로직의 흐름을 재호라용할 수 있다.
- 중요한 것은, 함수를 호출하는 부분에서 함수를 실행하고 다시 원래 자리로 돌아올 방법이 필요하단 것.
- 어디서 함수로 들어갔는지 기억해야 하고, 이는 프로그램 카운터 값이다.
- p.197에서 보면 사실 함수를 돌리는 데는 많은 작업이 필요하다.
- 그렇기 때문에 대부분의 프로세서는 이를 돕는 명령어가 있다.
  - ARM의 BL(Branch with Link) 명령어라던지.

## 스택
- 함수는 다른 함수를 호출하거나 자기 자신을 호출하기도 한다.
  - 후자의 경우 재귀라고 하는 건 다들 알 테고.
  - 재귀적 분할은 다름아닌 JPEG 압축에 사용된다.
  - 설명은 됐고, 주요 용어는 트리, 공간 데이터 구조 등이 있다. 쿼드트리는 공간 데이터 구조라네?
- 재귀 함수가 제대로 작동하려면 반환 주소를 여럿 저장할 수 있어야 한다.
  - 또한 저장된 이 여러 주소 중 뭘 쓸지 결정할 수 있어야 한다.
  - DFS를 통해 이것이 결정된다!!! 와우.
- 그렇다면 뭔가 쌓아 둘 수 있는 자료구조가 필요할 것 같은데. 그래서 함수 콜 "스택"이라는 것이 만들어졌다.
  - 모든 함수는 자신이 전달받은 반환 주소를 나중에 사용하기 위해 스택에 던져 넣는다.
  - 한편 대부분의 컴퓨터는 스택뿐만 아니라, 오버플로우를 검사할 필요를 줄이는 한계 레지스터도 포함한다.
- 스택은 반환 주소만 저장하는 장소는 아니다.
  - 정확히는, 함수가 호출될 때마다 스택에 저장되는 필요한 데이터의 모음을 스택 프레임이라고 부른다.
  - 스택 프레임에는 함수 내에 정의된 지역변수 등이 있을 수 있다.
- 참고. 전위 표기법(폴란드 표기법), 역 폴란드 표기법

## 인터럽트
- 일의 흐름은 순서도, 플로우 차트로 표현할 수 있다.
- 쿠키를 만들고 있는데 방문자가 온 상황을 가정할 것.
- 너무 외부인을 오래 기다리지 않게 하기 위해 각각의 과정마다 방문자가 있는지 확인하며, 이를 폴링이라고 한다.
  - 잘 작동하는 편이지만 비효율적이다.
- 차라리 외부인이 "방해"할 수 있게 하면 일의 효율도 늘고 응답성도 빨라지지 않을까?
- 이 방해가 바로 인터럽트이다.
- 인터럽트 시스템은 적절한 전기 신호가 들어오면 CPU 실행을 잠시 중단시킬 수 있는 핀을 포함한다.
  - 요즘은 통합 주변 장치에 다 들어 있다.
- CPU가 주의를 기울여야 하는 "방문객"은 인터럽트 요청을 생성한다.
- 프로세서는 일단 지금 실행 중이던 명령어까지 실행하고, 잠시 프로그램을 중단시킨 다음 인터럽트 핸들러를 실행시킨다.
- 쿠키의 예제에서 인터럽트 요청은 초인종과 같다.
- 인터럽트 처리에 있어 몇 가지 고려할 요소
  - 응답 시간
  - 처리한 후 돌아올 상태
- 그래서 인터럽트 시스템은 서비스 후 돌아올 프로그램 위치를 스택에 저장한다.
- 한편 인터럽트 핸들러 함수를 찾기 위해, 미리 정해진 주소가 입력되어 있다.
  - 이 미리 정해진 주소에는 여러 인터럽트 벡터가 들어 있다.
  - 각 인터럽트 벡터는 CPU가 지원하는 각 인터럽트 핸들러의 주소를 지정한다.
  - 인터럽트 벡터는.. 메모리 위치를 가리키는 포인터일 뿐. 화살표와 같다.
- 많은 기기가 물리적 주소를 벗어나는 주소 사용 시도나, 스택 오버플로우나, 같은 예외 사항에 대한 인터럽트 벡터를 제공한다.
  - 이 경우 오류가 났더라도 인터럽트에 던지고 프로그램을 계속 쓸 수 있기도 하다(!!!)
- 특별한 인터럽트 제어도 있다.
  - 특정 인터럽트 켜거나 끄기, mask
  - 인터럽트 우선순위 간의 차이. 인터럽트의 인터럽트인거임
  - 일정 시간이 지나거나 일정 시간 간격으로 인터럽트를 발생시키는 내장 타이머
- 운영체제만이 접근할 수 있는 물리적(하드웨어) 인터럽트, 가상 인터럽트(e.g. 시그널, 이벤트, ...)

## 상대 주소 지정
- 여러 프로그램을 동시에 실행하려면 어떻게 해야 할까?
  - 프로그램 전환을 담당하는 관리자 프로그램 (운영체제 커널)
  - OS는 시스템 프로그램, 다른 거는 사용자 프로그램 혹은 프로세스.
- p.207의 흐름에서, 타이머 인터럽트가 있지?
  - 타이머를 사용해 사용자 프로그램을 전환시켜줄 때가 됐는지 판단하고, 실행 시간을 조정한다.
  - 이런 스케줄링 기법을 시분할이라고 한다.
  - 사용자 프로그램 상태 혹은 컨텍스트는, 레지스터의 상태와 프로그램이 사용 중인 메모리의 상태를 뜻한다(스택 포함).
- 그런데 한 번에 하나의 프로그램만 실행시킨다면 아주 느릴 것이다.
  - 만약 프로그램별로 메모리의 다른 공간을 허용할 수 있다면 시분할이 훨씬 빨라질텐데.
- 그래서 프로그램에게 지정된 메모리 구획을 준다. 하지만 잠깐, 어떻게?
- 절대 주소 지정의 경우, 인덱스 레지스터를 통해 명령어의 주소와 더해서 유효 주소를 계산하고 배치한다.
- 상대 주소 지정의 경우, 명령어에 들어 있는 주소를 0부터 시작하는 위치로 해석하지 않고 명령어의 주소를 기준으로 하는 상대 위치로 해석한다.

## 메모리 관리 장치
- 이제 멀티태스킹은 필수.. 백그라운드 실행도 따라온다..
- 서로의 메모리 영역을 침해하는 것을 막기 위해 메모리 관리 장치가 있다.
- MMU 탑재 장치는 가상 주소와 물리 주소를 구분한다.
- MMU는 가상 메모리 주소를 두 부분으로 나눈다.
  - 아래 부분은 물리 주소 범위와 같다.
  - 위 부분은 RAM 페이지 테이블 영역을 통해 주소를 변환한다.
- 예제에서는 메모리가 256바이트 크기의 페이지로 분할된다.
  - 페이지 테이블에는 각 페이지가 실제로 물리 메모리상에서 차지하는 주소가 써 있다.
  - 가상 메모리는 연속적으로 보여질지 몰라도, 물리 메모리상에서는 연속적일 필요가 없다!!
- 심지어 협동하는 프로그램들 사이에 같은 물리 메모리 영역을 사용하는 공유 메모리 기능을 제공하기도 한다.
- 이제 이렇게 되면 페이지 테이블의 내용이 프로그램 컨텍스트에 포함된다.
- 현대적 프로세서의 MMU는 페이지 테이블 크기가 정해져 있다. 
  - 그리고 이걸 넘는 페이지 테이블 항목은 디스크에 저장해 둔다.
  - 그러면 페이지 테이블조차도 필요한 부분만 불러온다.
- 실행 불가 비트를 통해 CPU가 그 페이지에 있는 명령어를 실행하지 못하게 할 수 있다.
- 읽기 전용 비트를 사용하는 방법도 있다.
- 프로그램이 물리적 메모리에 연관되지 않은 주소에 접근하면 페이지 폴트가 발생한다.
  - 스택 오버플로우 발생시 이를 응용해, MMU에 추가 메모리를 할당할 수 있다.
- MMU로 인해 폰 노이만 구조와 하버드 구조의 구분이 의미없어졌다.
  - 폰 노이만의 단일 메모리 버스만 가지고도 명령어 메모리와 데이터 메모리를 분리해서 제공할 수 있다!

## 가상 메모리
- OS가 관리하는 메모리. MMU를 통해 가상 메모리를 프로그램에게 제공한다!
- 가상 메모리로 인해 프로그램은, 그 자신의 실행에 충분한 메모리가 있다고 전제할 수 있게 됐다.
- 그런데 요청받은 메모리가 사용 가능한 물리 메모리 크기보다 크다면?
  - OS는 현재 필요없는 메모리 페이지를 디스크로 스왑아웃 한다.
  - 스왑아웃된 메모리에 프로그램이 다시 접근하면, 운영체제는 메모리에 공간을 다시 내고 스왑인을 수행한다.
  - 이런 식의 페이지 처리를 요구불 페이징이라고 부른다.
- 스왑이 자주 일어난다면 성능은 많이 저하된다.
- 하지만 아예 프로그램을 못 돌리는 것보다는 낫다.
- 그래서 가상 메모리 시스템은 스왑으로 인한 성능 저하를 최소화시키고자 다양한 기법을 활용한다.
  - LRU 같은 메모리 관리 알고리즘이 여기서 등장!

## 시스템 공간과 사용자 공간
- 지금까지 알아본 멀티태스킹 시스템은, 마치 하나의 프로그램을 돌리는 것처럼 여러 개의 프로그램을 돌린다.
- 그런데 I/O 장치가 끼어들면 뽀록이 나지 않을까?!
- 사용자 프로그램에 의해 타이머 인터럽트의 주기가 바뀌어 버리면 모든 것이 망하지 않을까?
- 이를 막기 위해 CPU에는, 컴퓨터가 시스템 모드에 있는지 유저 모드에 있는지 결정하는 비트가 들어 있다.
- 일부 명령어는 특권 명령어로써, 오직 시스템 모드일 때만 작동한다.
  - 그리고 사용자 모드에서는 시스템 콜을 통해 시스템 모드 프로그램 즉, 운영체제에게 요청을 보낼 수 있다.
- 이를 통해 운영체제가 프로그램에 대한 자원 할당을 전적으로 제어할 수 있다.

## 메모리 계층과 성능
- 많은 메모리는 각기 속도가 다르다.
  - 스와핑에서 그 편린을 봤다.
- CPU는 당연히 가장 빠르다. CPU에 붙어 있는 레지스터도 마찬가지.
- CPU에 발맞추기 위해 캐시를 CPU에 추가한다.
- DRAM에서 연속된 데이터를 가져오는 것이 빠르다는 것에 착안해 시스템 성능을 높일 수 있다.
- 캐시도 몇 가지 계틍이 있다. L1~L3 캐시는 들어 봤을 것.
  - 캐시 히트, 캐시 미스
- 성능을 위해 프리페치, 분기 예측, 순서를 벗어나는 실행 등의 기법을 통해 더 성능을 높일 수 있다.
- 캐시 일관성의 유지는 중요하며 어려운 문제다.. 라는 것까지만 일단 알고 넘어가자.

## 코프로세서
- CPU의 몇 가지 연산을 코프로세서라는 단순한 회로에 위임하면, 프로세서가 연산할 수 있는 범위가 늘지 않을까? 에서 착안.
- 요즘 프로세서에서는 그래픽 처리 등 여러 가지 기능으 ㄹ담당한다.
- 이전에 살펴 본, 더 느리고 더 싼 메모리에 들어 있는 내용을 불러 오는 내용을 기억하는지?
  - 그 얘기는, 단순 데이터 입출력 작업이 굉장히 자주 일어난다는 뜻이다.
  - 일부 코프로세서는 데이터 복사만 담당한다. 이를 직접 메모리 접근, DMA라고 한다.
  - CPU는 실제로 DMA 장치에 짬을 많이 때린다(...).

## 메모리상의 데이터 배치
- 메모리에는 명령어뿐 아니라 데이터도 담기며, 이 경우 데이터는 static 데이터다.
- 크기가 정해져 있기 때문에 메모리 배치 시 고려할 수 있다.
- 한편 프로그램은 동적 데이터를 다룬다.
  - 동적 데이터는 정적 데이터 위의 영역에 쌓이며 이를 힙이라고 한다.
- p.218 그림을 보면 알겠지만, 스택과 힙이 충돌하지 않게 하는 것이 중요하다.
- 특히 마이크로컴퓨터는 MMU가 없는 경우가 많아, 살짝 변형된 메모리 배치가 자주 보인다.
  - 메모리 시작/끝 부분에 인터럽트 벡터를 저장한다던지, 온칩 I/O 장치 제어 레지스터를 확보한다던지.
  - 명령, 데이터, 스택이 각기 다른 물리적 메모리 페이지에 매핑되고, 필요에 따라 크기를 변경할 수 있다.
  - 하지만 프로그램이 바라보는 가상 메모리는 여전히 같다.

## 프로그램 실행
- 그래서, 이 여러 부분이 어떻게 공조하느냐?
- 극한의 코드 재사용을 위해 함수를 모아서 라이브러리를 만들어 보자.
- 프로그램은 라이브러리를 포함한 여러 조각을 엮어서 만들어진다.
- 그렇다면 프로그램으로 될 때, 이 모든 조각을 하나로 묶는 링킹이 필요하겠지!
  - 그래서 링커라는 특별한 프로그램을 사용해 여러 조각을 하나로 연결해 실행한다.
  - ELF 형식은 현재 가장 유명한 매개 파일 형식이다.
  - 링커는 이 모든 것을 리졸브해서 실제 실행할 수 있는 프로그램을 만드는 프로그램이다.
- 링크할 때의 방법
  - 라이브러리를 단지 함수 뭉치로 해석해서, 나머지 부분과 직접 연결하는 정적 링크
  - 많이 쓰이는 라이브러리를 모든 프로그램에 박아 넣기보다, 공유 라이브러리를 사용해서 연결하는 동적 링크! 메모리는 소중하니까.
    - 단 동적 링크를 사용하는 라이브러리는, 라이브러리 함수를 호출하는 프로그램의 스택과 힙을 고려해 작성되어야 한다.
- 프로그램의 진입점. 가장 먼저 실행될 것 같지?
  - 하지만 실제로는 런타임 라이브러리가 추가되고, 그 명령어가 먼저 실행된 다음, 프로그램 진입점의 명령어가 실행된다.
- 왜 그러냐면, 런타임 라이브러리는 메모리 설정을 책임지기 때문이다.
  - 스택과 힙을 설정하며, static 데이터의 초기값도 설정한다.
  - 더 많은 기능도 수행하지만 여기서 커버하지 않는다.