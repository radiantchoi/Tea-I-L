# Medium iOS 팀이 레거시 코드를 가지고 (효과적으로) 일하는 방법
https://medium.engineering/how-the-medium-ios-team-works-effectively-with-legacy-code-0a9ddc45df19
- Medium iOS 코드베이스는 10년이 넘었다.
- 도대체 왜 얘네는 2013, 14년 코드를 아직도 안 갈아엎고 있나? 생각하는 사람이 있다.
- 사실 Medium iOS 팀에게는 이게 훈장 같은 건데, 하술

## Working errectively with legacy code
- 2004년 책. 실전적 엔지니어가 되고 싶다면 일독을 권한다.
- 리팩토링의 이론적 면모, 그리고 실전 케이스에 대해 논한다.
- 현대 iOS 개발에서 더 이상 통용되지 않는 레거시 코드, 분명 우리도 갖고 있다!

## 소프트웨어 갈아엎기

### 시간이 별로 없지만 해야 하는 경우
- "코드는 집이고, 너는 거기 살아야 한당께"
- 스토리 렌더링 코드가 Medium iOS 앱의 가장 레거시한 부분 중 하나.
- 2019년에 부분적으로 재작성되었다. 하지만 기존의 UIKit 렌더링 엔진과 디자인은 그대로 남겨 두었다.
- 그래서 세 가지 다른 부분으로 구성되어 있다.
    - 스토리 메타데이터를 담는 header
    - 본문. 텍스트나 사진이나, ...
    - 관련 포스트나 추천 등을 담고 있는 footer
- 이 중 본문은 지금으로도 좋다고 생각해서 레거시 그대로 남겨 뒀다.
- 하지만 header와 footer에는 새로운 기능이 필요해지기 마련!
- 그래서 상술한 도서에 묘사된 방법 중 **Sprouts** 방법을 사용했다.
    - 새 기능이 필요하고 새 코드로 작성될 수 있다면, 새로운 방법을 사용해 코드를 작성하고 필요한 곳에서 불러와라! 라는 것.
- footer에서 새로운 추천 기능을 구현하고자 할 때 이 방법을 토대로 개발했다.
    - SwiftUI로 개발하고 footer의 새로운 엘레멘트로 삽입함으로써 UIKit renderer에 집어넣었다!!

### 코드 이해도가 떨어지는 경우
- 잘 돌아가고 있지만 아무튼 진화시키긴 해야 하는 때.
- Medium 앱의 다크 모드를 구현해야 할 때 이런 일이 있었다.
- 각각의 UI 컴포넌트를 다크 모드에 대응시켜야 하는데, 이걸 하나하나 손으로 했어야 했다.
- 이전 케이스랑 비슷하지만, 이건 앱 전체에 적용되는 사안이니까..!
    - 한편으로는 지금 라이트 모드인지 다크 모드인지 앱 내에서도 알았어야 했다.
- 수 년 동안, 피처 추가할 때마다 다크 모드 따로 대응하고, 그런 식으로 일했다.
- 바꿔야겠지..?
- Appearance Manager 비슷한 것을 두어 기존의 인터페이스를 컨트롤했고, 시스템 네이티브 모드 스위칭을 통해 신규 기능들은 자동으로 다크 모드에 대응되도록 했다.
    - 정확한 이름은 `UserInterfaceStylePreferenceService`
    - 시스템에서 모드를 바꾸면 `traitCollectionDidChange()` 메서드를 자동으로 트리거하고, 이를 통해 연동된 `UITraitEnvironment`와 `UIColor`를 대응하여 바꾸었다.

### 이 앱에 구조 따위는 없는 경우
- 앱에 구조는 당연히 중요하다만, 구조를 다시 짜는 건 시간이 많이 걸린다.
- 대신, 최소한의 구조를 현장에서 바로 적용하면 이를 따르기 더 수월하다.
- 이는 곧 모듈화를 위한 템플릿을 제공하는 것과도 같다.
- Medium에서 지금 새로 추가되는 기능은 모듈화가 잘 돼있고, 기존의 레거시 구조 위에 구현할 수 있도록 미리 짜 두었으며, 그간의 경험/모듈에 기반한 예시도 있다.
- "레거시를 놔두고 새 걸 짜지 마라" 같은 규칙은 우리는 없다.

### 클래스가 너무 커서 더 커지게 하고 싶지 않은 경우
- 레거시를 건들면서 가장 자주 마주했던 케이스가 아닌가 싶다. 다들 공감하시죠?
- Medium 앱의 푸시 알림 설정 화면이 대표적인 예시.
- API 엔드포인트를 GraphQL로 새로 짜기도 하면서, UI도 갈아엎어야 했다.
- 기존의 화면은 잘 작동했지만 여러 다른 것들이 얽힌 엄청나게 큰 `Settings` 클래스에 박혀 있었다.
- 기존에 있던 설정 화면 관련 코드를 자체 모듈로 빼고, (당연히 잘 작동하나 검증한 후에) 리팩토링 및 구조 다시 짜기를 수행했다.
- 상술한 책의 **Seeing responsibilities** 방법을 사용했다.
    - 말하자면, 서로 다른 책임을 구분하고, 점진적으로 각각의 책임의 집중도를 높이는 방향으로 가는 것이다.
    - 기존 코드에서 책임을 발견하는 것과, 새로운 코드로써 기능을 구현하고 책임을 확정하는 것은 의외로 크게 다르지 않다.
    - 레거시 코드는 새로운 기능을 쓸 때보다 디자인 패턴 적용 스킬을 적용할 만 한 훨씬 더 많은 여지가 있다.
- 기존의 코드에서 책임을 발견하고 뽑아냈을 때, 앞으로 리팩토링할 방향성을 제시받을 수 있었고, 이 과정에서 변경사항이 기존 레거시에 미칠 영향에 대해 크게 고민할 필요가 없었다.
    - 책임의 분리를 통해 어쨌든 그럴 가능성이 없어졌기 때문.

### 내가 코드를 조지고 있는지 아닌지 어떻게 알지?
- 우리가 고치고자 하는 레거시 코드가 각기 다른 많은 유즈케이스에서 엄청나게 많이 쓰이고 있다면?
    - 특히 의존성 측면에서 이러는 경우가 많다.
- 몇 달 전 Cocoapods 사용을 중단하고자 할 때 이런 일이 생겼다.
    - `KSDeferred`라는 Obj-C 라이브러리가 문제가 됐다.
    - JS Promise같은 기능을 하고, 우리는 이걸 completion 블록 기반의 비동기 코드로 바꾸고 싶었다.
- 이 때 상술한 도서에서 나온 두 가지 기술을 활용했다.
    - **Preserve signatures**
        - 테스트 후 안전하게 코드를 바꾸는 것이 곤란할 때, 쬐금만 리팩토링함으로써 적당히 testable한 시스템을 만들고자 할 때 유용하다.
        - 핫 스왑 과정에서 획기적일 정도로 에러에 덜 취약하게 된다.
    - **Lean on the compiler**
        - 컴파일러가 "이거 바꿔라"라고 안내하게끔 하고, 그것을 따라가면 된다.
- 이 방법을 적용할 때 수행한 작업은 두 가지.
    - 동일한 시그니처를 사용하는 새로운 코드를 준비한다.
    - 라이브러리 링크를 끊음으로써 컴파일러가 오류를 뱉게 하고, 이걸 하나씩 해결한다.
    - (Obj-C 코드 예시는 본 포스팅 참조)

## 재작성, 할 것인가 말 것인가
- 대부분의 팀이 (답도 없는) 레거시를 볼 때 처음 딱 드는 생각은, "하 처음부터 다시 짜야지"일 것이다.
- 우리는 이걸 최후의 보루로 남겨 두고, 사실 거의 염두하지 않는다. 왜냐면?
    - 코드는 쓰는 것보다 읽는 게 훨씬 어렵다. Joel Spolsky는 자신의 포스팅 Things you should never do에서 아예 이걸 명시했다.
    - 프로젝트 재작성은 매몰 비용의 오류에 빠지기 쉽다.
- 그래서 우리는 재작성 대신, 레거시를 그대로 두고 조금씩만 바꾸거나, 심지어 레거시를 끼고 작업하기도 하는 것.
- 이를 통해 우리는 해당 코드의 복잡미묘한 부분에 대해 더 알게 된다.
- 또한 충분히 분해/이해한 후에는 다른 나머지나, 심지어는 전체까지도 재작성을 할 생각을 한다. 앞에서 소개한 여러 가지 모던한 방법 가지고 말이다.
- 상술한 책의 저자 Michael C. Feathers는 책의 서문에 이렇게 말했다.
    - 좋은 구조 디자인은 우리 모두의 목표다만, 레거시 코드에서는 단계적인 과정을 거쳐 도달해야 하는 것이다.
- 필자 또한 이것에 동의한다. 단계적으로 도달하는 것의 힘을 얕보지 말라고!