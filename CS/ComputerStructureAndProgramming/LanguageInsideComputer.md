# 컴퓨터 내부의 언어 체계

## 언어란 무엇인가
- 의사소통의 편의를 위한 수단
- 언어의 뜻은 기호의 집합으로 인코딩된다.
- 의사소통 당사자들이 같은 문맥을 공유해, 같은 기호에 같은 뜻을 부여해야 언어가 제대로 기능한다.

## 문자 언어
- 문자 언어는 기호의 나열이다.
- 기호를 정해진 순서대로 나열하면 단어를 만들 수 있다.
- 언어마다 기호와 기호 유형, 읽는 순서도 다를 수 있다.

## 비트
- 비트는 기계어의 문자다. 2진법을 사용한다.
- 켜고 끔, 참과 거짓, 0과 1, 등등 여러 가지가 비트가 될 수 있다.

## 논리 연산
- 예/아니오 질문에 대한 답.
- 예는 `true`, 아니오는 `false`에 각각 대응한다.
- 한편 자연어에서는 여러 예와 아니오를 엮어 한 문장으로 만드는 경우가 있다.
- 이런 식으로, 다른 비트들이 표현하는 내용으로부터 새로운 비트를 만들어내는 동작을 논리 연산이라 한다.

### 불리언 대수
- 비트에 대해 사용할 수 있는 연산 규칙의 집합이다.
- 결합 법칙, 교환 법칙, 분배 법칙을 적용할 수 있다.
- NOT, AND, OR 세 가지가 기본적으로 있고, XOR 합성 연산이 있다.
  - NOT: 논리적 반대를 의미한다. 거짓에 가하면 참이 되는 식으로.
  - AND: 둘 이상의 비트가 모두 참일 경우를 나타낸다.
  - OR: 둘 이상의 비트 중 하나라도 참일 경우를 나타낸다.
  - XOR(Exclusive OR): 두 개의 비트가 서로 다를 경우에만 참이다.
- 기본 불 연산을 다양한 방식으로 조합해 같은 결과를 얻을 수 있다.
  - 가령 a XOR b 연산은 (a OR b) AND (NOT(a AND b)) 라고도 볼 수 있다.

### 드 모르간의 법칙
- a AND b == NOT(NOT a OR NOT b)
- 이 말인즉, NOT을 잘 사용하면 AND를 OR로 바꿀 수 있다는 거다.
- 긍정적 논리인 정논리로만 항상 입력이 들어오지 않을 수 있다. 부정적인 부논리로 입력이 들어올 때, 이를 활용할 수 있다.
  - 이럴 때 연산을 연쇄적으로 사용하면 계산이 느려지는데, 드 모르간의 법칙을 활용해 이를 타개할 수 있다.

## 정수를 비트로 표현하는 방법

### 양의 정수 표현
- 통상적인 10진수 체계에서는 10가지 기호인 숫자를 상자 - 문자의 자리 - 에 넣을 수 있다.
- 오른쪽에서 왼쪽으로 자릿수를 채워 가며, 각 자릿수는 10의 거듭제곱을 곱한다.
  - 이를 밑이 10이라고 한다. base10 시스템이라고도 할 수 있다.
- 비트를 사용할 떄도 이와 비슷한다. 단지 10 대신 2를 사용할 뿐.
- 5028을 비트로 나타내면 1001110100100이 되는 것!
- 비트의 갯수는 표현할 수 있는 값의 범위를 결정한다.
  - base10 체계 상에서 0부터 99의 100가지 수를 두 자리로 표현할 수 있듯
  - 그리고 base2 체계 상에서 0부터 7까지의 8가지 수를 세 자리로 표현할 수 있듯
- 2진수에서 가장 오른쪽의 비트는 가장 작은 유효 비트(LSB), 가장 왼쪽의 비트를 가장 큰 유효 비트(MSB)라고 부른다.
- 컴퓨터는 미리 정해진 갯수의 비트를 한 덩어리로 쓰게 되어 있기 때문에, 숫자를 표현하는 데 필요한 비트보다 더 많은 비트를 쓸 수 있다.
  - 이 때 앞에 나오는 0들을 leading zero라고 부른다.
  - MSB가 꼭 1이지는 않은 셈이다. 값이 바뀌면 총 숫자가 가장 크게 바뀌는, Most Significant한 비트인 거니까.

### 2진수 덧셈
- LSB에서 MSB 방향으로 더하여 계산하며, 결과가 1보다 크면 1을 다음 자리로 올린다.
- 1비트 수 A와 B를 더할 때, 2비트 수 C의 첫 비트는 A AND B, 두 번째 비트는 A XOR B이다.
  - 두 비트를 더한 결과는 두 비트를 XOR한 결과와 같고, 올림은 두 비트를 AND한 값과 같다, 라고도 할 수 있다.
  - 두 자릿수만 쓰는 경우는 거의 없지 않냐! 싶은데, 3비트를 더할 때는 2비트 덧셈을 두 번 하면 된다.
  - A + B + C = (A + B) + C이므로.
- 덧셈 결과값이 주어진 비트를 넘어서면 오버플로우가 발생한다. MSB에서 올림이 발생했다, 라고 봐도 좋다.
  - 레지스터에 위치한 오버플로우 비트에는 MSB에서 발생한 올림값이 들어간다. 놀라움!
- 빼기는 그럼 어떻게 할까? 음수를 더하는 것이라고 볼 수 있다. 그러면 음수 표현법을 알면 되겠군?

### 음수 표현
- 음수와 양수를 구분하는 요소는 "부호"! 하나의 비트를 부호 할당용으로 사용한다. MSB를 사용해 본다.
- 예를 들면 8비트에서 표현할 수 있는 수의 범위는 그래서 -128~127이 된다. sign and magnitude 표기법이라고 한다.
- 이 방법은 두 가지 단점이 있는데...
  - 0을 표현하는 방법이 두 가지라 낭비가 된다.
  - XOR과 AND 연산을 활용한 덧셈이 불가능하다.
- 음수를 표현하는 또 다른 방법으로 1의 보수 방법이 있다. 양수의 모든 비트를 뒤집는 거다.
- 원래 수에 NOT 연산을 가함으로써 얻을 수 있다.
- 0을 두 가지로 표현하는 문제는 여전히 있다. 한편 덧셈도 쉽진 않은데, MSB에서 발생한 올림을 LSB에 더해야 한다.
  - 이 과정을 순환 올림이라고 하는데, 순환 올림만을 위한 하드웨어가 필요하다.
- XOR과 AND만 사용해야 하는 컴퓨터의 최종 솔루션은 **2의 보수**!
- 어떤 수의 비트를 모두 반전시킨(NOT) 다음 1을 더하면 해당 수의 음수라고 약속하는 방식!
  - 이 때 MSB에 발생하는 올림은 무시한다.
  - 4비트에서 0100(2), 즉 4의 음수는 1011 + 1(2), 즉 1100(2)가 되는 방식이다.
  - 마찬가지로 0111(2), 즉 7의 음수는 1001(2)가 되는 방식.
  - 한편 1000(2)는 -8이다.
- 2의 보수 방식은 0을 표현하는 방법이 한 가지이다.
- 기억해둬야 할 것은, 부호가 있는 수의 계산에서는 MSB까지 채워넣지 말아야 한다는 사실!

## 실수 표현
- 밑이 10인 실수에는 10진 소수점이 포함된다. 그럼 2진 소수점은 어떻게 표현하나?

### 고정소수점 표현법
- 정수 표현부와 분수 표현부를 고정해놓는 방식.
- 예를 들면 4비트 중 2비트는 정수 부분, 2비트는 소수점 아래 부분을 분수로 표현하는 부분으로 나눌 수 있다.
  - 10의 거듭제곱 대신 2의 음의 거듭제곱을 소수점 자릿수로 본다고 생각하면 쉽다.
- 근데 실제 세상의 모든 수를 이렇게 표현할 수는 없다.. 비트가 너무 많이 필요해질걸.

### 부동소수점 표현법
- 과학적 표기법을 도입한다. `0.00012`는 곧 `1.2 * 10^-3`이라고 할 수 있는 거니까.
- 가수 부분은 소수점 위가 한 자리인 2진 소수, 지수 부분은 2의 거듭제곱, 으로 가면 된다.
- 부동 소수점이라고 부르는 이유는, 소수점 위치가 고정된 표기처럼 보이지만 사실 아님을 알리기 위해서이다.
  - 지수가 무엇이 곱해지냐에 따라 가수의 소수점 왼쪽 한 자리가 1000의 자리일수도, 소수 둘쨰 자리일 수도 있기 때문.
- 그런데 깡으로 부동소수점을 쓰면, 예를 들어 4비트를 쓴다고 할 때, 0을 표현하는 방법이 네 가지나 된다.
  - 2비트를 가수를 표현하기 위해 쓰고 2비트를 지수로 쓸 때, 2비트는 4가지 경우가 있을 수 있기 때문..
- 한편 비트 패턴으로 가능한 모든 수를 표현할 수 없다는 단점 역시 존재한다.

### IEEE 754 - 부동소수점 수 표준
- 비효율을 해결하기 위해 여러 트릭을 썼다.
- 먼저 정규화를 통해 가수를 조정해서 맨 왼쪽에 0이 없게 만든다.
- 다음으로 맨 왼쪽 비트가 어차피 1인 걸 아니까, 이를 생략한다. 이로써 가수에 1비트를 더 쓸 수 있다.
- 기본 정밀도 부동소수점 수(32비트)와 2배 정밀도 부동소수점 수(64비트)가 있다.
  - 후자가 전자에 비해 지수가 3비트 크며(따라서 범위는 8배 더 크다), 가수는 무려 29비트 더 크다.
  - 가수의 크기는 정밀도를 담보한다. 다만 이게 비트를 2배씩 잡아먹고 얻은 이점이라는 사실..
- 또한 마지막 비트 - MSB는 가수의 부호로 사용한다.
- 지수의 부호는 따로 없는데, biased 지숫값을 활용해 해결했다.
  - 기본 정밀도 float의 bias는 01111111, 즉 127이며 이것이 지숫값 0을 표현하게 해 두었다.
  - 따라서 00000001은 -126인 것이다.
- 이 방식은 양의 무한대, 음의 무한대, NaN 등의 다양한 표현을 위한 비트도 제공한다. 모두 0이거나 모두 1이거나 한 특별한 파츠.

## 2진 코드화한 10진수(BCD) 시스템
- 4비트를 활용해 10진수 자릿수를 하나 표현한다.
- 12를 예로 들면 2진수로는 1100이지만 BCD로는 0001 0010이다.
- 요즘 컴퓨터엔 잘 안 들어가긴 하는데, 디스플레이나 가속도 센서 등에서 사용되니까 알아는 두자.
- 사실 2진수를 효율적으로 쓰지 못하긴 한다.

## 2진수를 다루는 쉬운 방법
- 눈아프지 않습니까?

### 8진 표현법
- 2진수를 세 개씩 묶는다.
- 100101110001010100101001 -> 100 101 110 001 010 100 101 001 -> 45612451

### 16진 표현법
- 위의 8진 표현법보다 한층 널리 쓰이는 방식!
- 100101110001010100101001 -> 1001 0111 0001 0101 0010 1001 -> 9715219
- 당연히 모자란 수는 ABCDEF로 채우면 되는 거 알고 있지?

### 프로그래밍 언어의 진법 표기법
- 0x가 붙으면 16진수다 일단.
- 0이 붙으면 8진수라는 식으로 정한 언어도 있나 본데, Swift string literal 상에선 0o였던 것 같다.

## 비트 그룹의 이름
- 컴퓨터가 사용할 비트의 개수와 비트의 조직을 결정해야 한다. 효율적인 비트 사용을 위해!
- 비트는 기본 단위로 사용하기는 너무 작다.
- 그래서 8비트를 묶어 바이트 단위로 만들고 기본 단위로 사용한다.
- 한편 워드는 32비트(즉 4바이트)를 가리키는 말로, 컴퓨터가 빠르게 처리할 수 있는 가장 큰 덩어리이다.
- 큰 수를 나타내기 위해 킬로, 메가, 기가, 테라, ...를 사용하는데, 2를 밑으로 하는 가장 가까운 수를 사용한다.
  - 그러니까 킬로바이트는 1000바이트가 아니라 1024바이트인 셈.
  - 근데 디스크 크기를 다룰 때는 밑이 10인 값을 쓴다.
  - 그래서 KB는 1000바이트가 됐고, KiB는 1024바이트가 됐다.

## 텍스트 표현
- 비트로 수를 다루고, 비트를 통해 이젠 문자도 다뤄 보자.

### ASCII 코드
- 65는 "A". 97은 "a"인 바로 그 녀석!
- 0은 30이다.
- ACK 같은 특수한 신호 문자도 구현되어 있다니..! SYN은 22, ACK은 06이다.

### 다른 표준
- 아니 평생 영어만 쓸거냐고?
- 각기 다른 표준이 난립한 끝에 8비트 단위의 비트에 문자를 나열하는 유니코드가 생겨났다.
  - 왜 아스키도 결국 문자에 일련번호를 매겨서 나열한 거인걸.

### 유니코드 변환 형식 8비트 (UTF-8)
- 원래는 7비트만 쓰지만, 컴퓨터가 다루는 덩어리는 바이트 즉 8비트니까..
- 문자 코드에 따라 각기 다른 인코딩을 사용함으로써 8비트, 아니 7비트 안에 문자를 욱여넣는다.
  - 여기서 인코딩이란 다른 비트 패턴을 표현하기 위해 사용하는 비트 패턴. 추상화의 추상화인거임~
- 모든 아스키 문자를 8비트로 표현하기 때문에, 아스키 문자를 쓸 때는 추가 공간이 필요치 않다.
- 또한 아스키가 아닌 문자를 받을 때도 프로그램이 깨지지 않에 잘 알아서 한다.
- 문자를 8비트 덩어리(옥텟)의 시퀀스로 인코딩한다.
  - 첫 덩어리의 MSB 쪽에 있는 비트들이 8비트 덩어리 시퀀스의 길이를 표현한다.
  - 그래서 문자의 경계를 찾기 쉽다!
- 유니코드 파이 기호를 UTF-8로 변환하는 과정을 참조하자.

## 문자를 사용한 수 표현
- UTF-8은 결국..
  - 문자(A)를 표현하는 비트들(0000000001000001)
  - 에서 나온 숫자들(0x0041)
  - 을 표현하는 숫자들(UTF-8 인코딩 값)
  - 을 표현하기 위해 숫자를 사용한다(0x41)
- 하지만 마지막 단계에서, 숫자를 표현하기 위해 숫자 말고 문자를 쓸 수도 있다는 사실! (어질)
- 2진 데이터를 주고받고 싶은데, 알다시피 아스키 코드 상당 부분은 제어 문자로 예약되어 있었다. 그리고 제어 문자는 시스템마다 처리 방식이 달랐다(...).

### Quoted-Printable Encoding
- 8비트 데이터를, 7비트만 지원하는 통신 경로로 송수신하기 위한 인코딩 방법.
- 주로 전자우편의 첨부를 처리하기 위해 사용됐다.
- `=` 다음에 바이트의 각 니블(4비트)을 표현하는 16진 숫자 2개를 추가해 8비트값을 표현한다.
- 몇 가지 규칙이 더 있다.
  - 줄 맨 끝에 오는 탭이나 스페이스 등 공백 문자는 각각 =09와 =20으로 표현해야 한다.
  - 인코딩된 데이터는 한 줄에 76자를 넘을 수 없다.
  - 어떤 줄의 맨 뒤가 `=` 기호로 끝나면 가짜 줄바꿈을 뜻하며, 수신 측에서 이를 제거하고 해석한다.

### Base64 Encoding
- QP 인코딩은 1바이트 표현하려고 3바이트를 쓰는 족속이다!
- Base64는 3바이트를 4개의 문자로 표현한다.
- Base64 표가 있는데, 여기 첨부하지는 않고..
- 0, 1, 2를 나타내는 3바이트를 인코딩한다고 해 보자.
  - 000000000000000100000002 -> AAEC
  - 3바이트를 24비트로 보고 6비트 네 덩어리로 나눈 다음, 각 6비트 덩어리값에 출력 가능한 문자를 할당해 표현한다.
- 모든 3바이트 조합을 4바이트 조합으로 변환할 수 있다.
- 여전히 이메일 전송에 많이 쓰인다!

### URL 인코딩
- 퍼센트 인코딩이라고도 부르며, `%` 기호 뒤에 16진 표현을 덧붙임으로써 문자를 인코딩한다.
- `/` 기호는 URL 인코딩에서 특별한 의미가 있는데, 단순히 / 문자를 표현하고 싶다면 그래서 %2F를 사용한다.
  - 아스키 코드가 47이기 때문에 이렇게 표현할 수 있다! 47 -> 2F -> %2F
- 한편 위에서 보이듯 `%` 기호도 특별하기 때문에, % 문자 리터럴을 표시할 때는 %25를 사용한다.

## 색을 표현하는 방법
- 컴퓨터 그래픽스는 픽셀 모눈종이에 점(blob)을 찍어서 그림을 만드는 거다.
- 컴퓨터의 기본 색 표현법은 RGB이다. 
- 또한 가산 합성법을 사용하여, 모든 색이 최댓값이라면 흰색이 나온다.
  - 가산 합성법이 더 많은 색을 만들어낼 수 있다고..
  - 단, 인쇄물과 색상이 다를 수 있기 때문에 여러 보정을 한다.
- 24비트 안에 8비트의 색 세 가지 정보를 가지고 색을 표현한다.
- 그런데 컴퓨터가 주로 사용하는 비트 묶음은 32비트 word인지라, 안 쓰는 8비트가 남게 되는데..

### 투명도 추가
- 각 픽셀에 알파라는 투명도 값을 추가하게 된다.
- 결국 RGB 값 각각에 알파를 곱한 만큼의 색이 실제로 부여된다는 것.

### 색 인코딩
- `#` 뒤에 여섯 자리 16진 숫자를 추가하는, 16진 트리플렛을 사용한다.
  - `#FF3333`은 조금 밝은 빨간색.
  - FF -> 11111111 -> 255
  - 33 -> 00110011 -> 51
  - 다만 이 표현 방식으로 알파를 표현할 수는 없다.

## 정리
- 단순한 비트를 이용해 아주 큰 숫자나 문자, 색 등의 복잡한 요소를 표현하는 법
- 10진수 -> 2진수, 2진수의 사칙연산, 음수와 분수의 표현
- 비트를 사용해 문자를 인코딩하는 표준