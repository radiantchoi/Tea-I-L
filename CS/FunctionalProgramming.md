# 함수형 프로그래밍

## 용어와 특징
- 함수형 프로그래밍 환경 하에서의 함수는 일급 시민이다.

### 일급 시민 (First-class Citizen)
- 일급 시민이란 함수 자체가 타입으로 기능하거나, 함수의 파라미터 값으로 넘길 수 있거나, 반환값으로 반환될 수 있음을 의미한다.

### 람다 계산법과 불변성
- 함수형 프로그래밍은 람다 계산법을 그 기초로 한다.
- 람다 계산법은 심볼이 변경되지 않는다는 것에 그 근간을 두고 있다. 이를 불변성이라 한다.
  - 쉽게 말해 외부의 가변 변수를 쓰는 대신 심볼에 값을 할당하면 변하지 않는다는 것.
``` Swift
class Myclass {
    var number: Int = 1
    
    // 함수 외부의 값을 변경시키므로 값의 불변성을 만족하지 않는다
    func increment(_ input: Int) -> Int {
        return input + number
    }
    
    // 함수 외부의 값을 변경시키지 않으므로 값의 불변성을 준수한다
    // 또한 Swift에서는 기본적으로, 파라미터로 주어진 자료에 연산을 가할 수 없다
    func functionalIncrement(_ input: Int) -> Int {
        return input + 1
    }    
}
```

### 순수함수 (Pure Function)
- 수학의 함수 개념에서 기인한다.
- 동일 입력, 동일 결과를 보장한다면 순수한 함수이다. 순수함수는 부작용이 없다.
- 함수형 프로그래밍에서의 함수는 순수함수이다.
- 여담으로, 프로그래밍 언어는 수학에서 사용하는 순수하고 선언적인 함수와 달리 단지 계산 절차를 표현한다.
  - 수행하고자 하는 명령의 묶음이라고 받아들여지는 경우가 더 많은듯..
  - 그래서 초창기에는 function 이라고 부르지 않고 routine 혹은 procedure 라고 부르는 언어가 많았다.

### 참조 투명성과 부작용
- 순수함수로 만들면 함수 외부의 값이나 객체를 참조하거나 의존적으로 동작하지 않기 때문에 참조투명성을 가지고, 부작용이 없다.
  - functionalIncrement의 경우 동일한 숫자를 넣으면 항상 동일한 숫자를 반환한다.
- 반대로 말하면 부작용이 있는 함수는 입력 값이 동일해도 함수 외부 값에 따라서 다른 값을 반환한다.
  - 상술한 increment의 예시. number의 값에 따라 반환값이 달라진다.

### 람다와 클로저
- 클로저는 람다 계산식을 코드로 구현한 것이다.
- 선언된 범위(스코프)에서 접근 가능한 변수를 캡처해서 저장한다.
  - Swift 클로저의 경우 캡처한 변수를 참조한다. 메모리 누수의 위험성과 `weak self`의 필요성!
- 이름 없는 함수로서 literal하게 작성할 수 있다.
  - 반대로 생각해 보면 함수는 이름 있는 클로저다, 라고도 할 수 있다. 후술
``` Swift
exntesion MyClass {
    func closureBasedIncrement(_ input: Int, action: (Int) -> Int) -> Int {
        return action(input)
    }
    
    func useClosureHere(_ input: Int) -> Int {
        return closureBasedIncrement(input) {
            $0 + 1
        }
    }
}
```

## 함수형 프로그래밍의 실제 (in Swift)

### 함수와 클로저
- 먼저 함수는, 공식 문서에 따르면, 특정 기능들을 수행해주는 코드의 모음이다. 이 함수는 불려옴으로써 그 일을 하게 된다.
- 다음으로 클로저는, 전달되고 사용될 수 있는 하나의 코드 블록이다. 
  - 클로저가 정의된 컨텍스트에 있는 어떤 외부 프로퍼티라도 접근하여 값을 가져올 수 있고, 또 변경할 수도 있다.
- 글로벌하면서도 여러 계층 안에 있는 코드들은 보통 함수로 정의되는데, 함수는 사실 특별한 클로저라고 할 수 있다!
    - 전역 함수는 이름이 있고 값을 캡처하지 않는 클로저이다.
    - Nested function 역시 클로저다. 이름이 있고, 그들이 정의된 맥락에서 값을 가져올 수 있다.

### 객체지향 vs 함수형
- 개인적으로 느낀 공통점은, “덩어리" 와 “처리" 이다. 
  - 코드의 덩어리를 통해 값을 처리하고 원하는 값을 반환한다는 데에서는 둘이 공통점이 있다고 생각되었다.
- 차이점이라면?
  - 중심이 되는 부분
    - 객체지향 패러다임은 클래스와 객체의 관계를 중심으로 코드 작성이 이루어진다. 상태, 프로퍼티, 메서드 등이 긴밀한 관계를 가지고 있다. 
      - 특히 프로퍼티가 어떤 상태를 가지고있는가에 따라 결과가 달라진다. 
      - 코드 작성 시에는 함수의 동작부를 캡슐화하여 코드를 잘 이해할 수 있게 돕는다.
    - 함수형 프로그래밍은 값의 연산 및 결과 도출 중심으로 코드를 작성한다. 
      - 함수 내부에서 인자로 받은 값을 별도로 저장하지 않고, 처리하는데에 주 목적을 둔다.
  - 일급 객체
    - 객체지향에서는 클래스가 일급 객체고, 함수형에서는 함수가 일급 객체다. 
      - 일급 객체란, 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체.
  - 불변성의 보장
    - 객체지향에서는 프로퍼티 즉 변수의 불변성이 보장되지는 않는다. 오히려 그 상태가 구동에 큰 영향을 미친다. 
    - 반면 함수형 프로그래밍에서는 한번 정해진 값은 바뀌지 않는다. 데이터를 처리할 땐, 단지 그 처리를 거친 새로운 값을 반환할 뿐.
  - 가독성
    - 데이터의 가공 흐름을 보고자 할 땐 함수형 프로그래밍 코드가 읽기 편한 면이 있다.
      - 절차적, 선언적 과정에 비해 코드의 양이 대체로 적다는 것도 장점.
    - 하지만 객체 지향 코드도 네이밍 및 매직 넘버의 분리에 조금 더 신경 써 주면 읽기 좋은 코드를 만들 수 있다. 