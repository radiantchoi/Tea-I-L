# 프로세스

## 프로세스란?
- CPU가 처리하는 작업. Task라고도 한다.
- 실행 중인 프로그램을 뜻하기도 한다.
- 디스크에 저장되어 있던 실행 가능한 프로그램이 메모리에 적재되어 운영체제가 관리하는 상태를 의미한다.

## 컴퓨터 구조

### 폰 노이만 구조
- 폰 노이만이 설계한 디지털 컴퓨터 설계 구조이다.
- 처리 장치, 컨트롤 유닛, 메모리, 외부 대용량 저장장치, 입출력 메커니즘으로 구성되어 있다.
    - 처리 장치는 산술 논리 장치와 프로세서 레지스터를 포함한다.
      - 산술 논리 장치는 컴퓨터의 모든 연산이 되는 기본 블럭이다.
      - 프로세서 레지스터는 우리가 흔히 레지스터라고 알고 있는, 계산 중인 값을 저장하는 매우 빠른 저장소이다.
    - 컨트롤 유닛은 명령 레지스터와 프로그램 카운터를 포함한다.
      - 명령 레지스터는 현재 실행되거나 디코딩되고 있는 명령을 저장하는 레지스터.
      - 프로그램 카운터는 다음으로 실행할 프로그램의 주소를 저장하고 있는 일종의 레지스터이다.
    - 메모리는 데이터와 명령어를 저장한다. 데이터와 명령어를 저장한다는 것에 주목!
- 폰 노이만 구조의 데이터 처리 방식은 내장 메모리 순차 처리 방식. 
  - 나열된 명령을 순서대로 처리하고, 그 결과에 따라 저장소의 값을 변경하는 방식이다.
  - 이러한 방식 때문에 폰 노이만 병목 현상이 일어난다. 
    - 데이터 메모리와 프로그램 메모리가 구분되어 있지 않고 하나의 메모리에 담겨 하나의 버스를 가지고 있는 구조
    - 따라서 CPU가 명령어와 데이터에 동시 접근할 수 없다.
- 폰 노이만 구조는, 소프트웨어의 교체만으로 컴퓨터에 다른 작업을 시킬 수 있기 때문에, 범용성이 크게 증대되었다는 의의가 있다.
    - 원래는 컴퓨터가 다른 작업을 하게 하기 위해서, 스위치를 배치하고 전선을 바꿔 끼우고 해서 데이터를 전송해서 신호를 처리하는 식으로 했다..
- 현대의 거의 모든 컴퓨터는 폰 노이만 구조를 기반으로 설계되었다.

### 하버드 구조
- 하버드 마크 1이라는 컴퓨터의 구조로부터 유래된 이름. 주로 폰 노이만 구조에 대비되는 뜻으로 많이 사용된다.
- 폰 노이만 병목 현상의 해결을 위해, 명령어 메모리와 데이터 메모리를 분리한 구조이다. 
  - 분리된 메모리를 가지고 있기 때문에 명령을 메모리로부터 읽어들이는 것과 데이터를 메모리로부터 읽어들이는 것을 동시에 할 수 있다.
- 다만, 이를 위해서는 더 많은 회로를 사용해야 한다. 당장 메모리를 분리한다는 것이 그것을 암시하는 것.
- 또한, 프로그램 자체에 데이터가 혼합되어 있는 경우 과정이 복잡해진다.
    - 예를 들어 프로그램이 가지고 있는 폰트 등의 데이터는 엄연히 “데이터" 이므로, 데이터 메모리에서 찾고자 할 것이다.
    - 하지만 폰트는 해당 프로그램으로 표시할 데이터가 아닌 해당 프로그램의 설정에 가까우므로 명령 메모리에 같이 있는 경우가 있다.
    - 이 경우, 명령 메모리에서 데이터를 찾아올 수 있게 하는 명령어를 짜야 한다.

### 현대의 컴퓨터
- 하버드 구조와 폰 노이만 구조를 적절히 섞어 효율성을 증대시킨 경우가 많지만, 본질적으로는 폰 노이만 구조에 기반한다.
- 명령 캐시와 데이터 캐시, 두 가지의 캐시와 CPU 간의 관계를 설계할 때 하버드 구조가 응용된다.

## 프로세스 스케줄링

### 프로세스 상태
- 생성(New): 프로세스가 막 생성된 상태. 준비 큐에 프로세스를 삽입힌다.
- 준비(Ready): 프로세스가 CPU에 의해 실행될 준비가 된 상태.
- 실행(Running): 프로세스에 포함된 명령어가 실행 중인 상태.
- 대기(Waiting): 프로세스가 특정 자원이나 이벤트를 기다리고 있는 상태.
  - Ready Queue에 있는 첫 번째 프로세스에 대해 Waiting -> Running의 상태 전환은 Dispatch라고 한다.
  - Running -> Waiting으로의 상태 전환은 Interrupt라고 한다.
  - Interrupt를 통해 실행 중인 프로세스가 바뀌는 것을 문맥 교환(Context Switching)이라고 한다.
- 종료(Terminated): 프로세스의 실행이 완료된 상태.

### 프로세스 스케줄링 방식
- 기한부 스케줄링
  - 데드라인을 주고, 그 데드라인까지 특정 프로세스를 완료하게 하는 방법
  - 프로세스 소요 시간과 데드라인을 고려해 지금 수행할 프로세스를 컴퓨터가 판단한다.
- 우선순위 스케줄링
  - 프로세스에 우선순위를 부여하고, 우선순위가 높은 프로세스부터 수행하는 방법
  - 우선순위가 낮은 프로세스는 (어쩌면 영원히) 실행되지 않는 Starving 문제가 있다.
- FIFO 스케줄링
  - 비선점 스케줄링!
  - 프로세스가 생성된 순서대로 대기 큐에 넣어 두고 처리하는 방법
- SJF 스케줄링
  - 비선점 스케줄링
  - 작업에 걸리는 시간이 가장 적은 프로세스부터 수행하는 방법
- Round Robin 스케줄링
  - 선점 스케줄링
  - 순차적으로 실행하되, 각각의 프로세스를 컴퓨터가 수행하는 단위 시간을 두는 방법
  - CPU에서 제어하는 시간, 즉 단위 시간이 끝날 때까지 프로세스가 끝나지 않으면 일단 다음 프로세스를 번갈아 수행한다.
  - 시간 단위가 너무 크면 FIFO와 다를 게 없고, 시간 단위가 너무 작으면 오버헤드가 커진다.
- Multi-Level Feedback Queue
  - 우선순위 방식으로 먼저 작동하되, 우선순위가 같은 작업들 사이에서는 라운드 로빈 방식을 적용하는 방법

### 선점 스케줄링과 비선점 스케줄링
- 선점 스케줄링은 다른 프로세스가 점유하고 있는 자원을 빼앗을 수 있는 방식이다.
  - 다만 CPU 자원을 빼앗을 때 컴퓨터가 그 이유를 판단할텐데, 판단 자체가 오버헤드를 불러일으킨다.
- 비선점 스케줄링은 다른 프로세스가 점유하고 있는 자원을 빼앗을 수 없는 방식이다.
  - 따라서 다른 프로세스가 작업이 끝날 때까지 기다려야 한다.
  - Deadlock의 발생 조건인 코프먼 조건 중 하나이다.

### iOS에서 스케줄링의 작동
- Mach 커널을 기반으로 한 XNU 커널을 사용하며, MLFQ와 RR 방식을 모두 지원한다.

## 스레드
- 경랑 프로세스라고도 하며, 프로세스에서 실행 제어만 분리해서 처리하는 단위이다.
- 같은 그룹의 스레드와 메모리 주소 공간, 운영체제 리소스를 공유한다.
- 프로세스는 하나 이상의 스레드를 가진다.
- 각각의 스레드가 가지고 있는 것은 다음과 같다. 
  - 스레드 실행 상태 관리
  - 실행을 위한 별도 스택
  - 지역 변수와 스레드의 특정 데이터를 저장하는 저장소
  - 프로세스의 메모리와 자원에 대한 접근을 기옥하는 컨텍스트 정보
- 스레드 또한 프로세스처럼 준비, 실행, 대기, 종료 상태가 있다.
- 스레드는 프로세스의 자원과 제어 중 제어만 분리한 것이다. 
- 스레드 생성 시 부모 프로세스와 공유할 자원을 초기화할 필요가 없다. 그 이유는 해당 프로세스가 스택과 레지스터를 제공하기 때문이다.
  - 이 때문에, 프로세스의 생성과 종료보다는 스레드의 생성과 종료가 훨씬 오버헤드를 덜 발생시키는 편이다.
- 또한 스레드 하나가 상태를 바꾼다고 해서 다른 스레드나 부모 프로세스의 상태 변화에 영향을 끼치지 않는다. 
  - 각각은 독립적으로 실행하되, 자원만 공유하는 것.
- 멀티 스레드를 지원하는 운영체제는 프로세스가 아닌 스레드 단위로 스케줄링을 한다.
- 스케줄러가 스케줄링 정책을 가지고 스레드의 상태를 변화시킴으로써, 스케줄링이 시작되고 스레드의 상태가 변하기 시작한다.

### 스레드 사용시 특징
- 스레드를 사용하면 사용자에 대한 응답성을 증가시킬 수 있다.
- 프로세스 자원과 메모리를 공유할 수 있다.
    - 자원을 공유하기 때문에 경제적이다.
- 다중 프로세서와 다중 스레드를 혼합해서 병렬 실행이 가능하다.
- 현대 CPU들은 다중 스레드를 처리하는 하드웨어 로직을 가지고 있다.

### Foreground Thread와 Background Thread
- 이 둘이 구분된다는 것 자체가 이미 멀티 스레드 환경임을 암시한다.
- 스레드를 명시적으로 생성하면 대부분 Foreground Thread로 생성된다.
- Background Thread는 우선순위가 낮은 작업이 주로 할당된다.
  - 우선순위가 낮은 작업이라면, 컴퓨터의 자원을 덜 할당해주는 방식으로 차이를 둔다.
- iOS에서는 GCD로 구현이 되어 있다.

### 번외 - 스레드를 무제한으로 만들면 어떻게 될까?
- 스레드를 무제한으로 만드는 것은 무한 개의 작업에 각각의 실행 단위를 준다는 의미.
- 하지만 프로세스에 할당된 자원은 한정적이고, 스레드에 주어지는 스택 메모리의 공간은 점점 작아지게 된다.
- 이러면 Stack Overflow 문제가 더 쉽게 발생하고, Context Switching에 따른 오버헤드도 더 커질 것이다.
- 그래서 이건 문제로 취급된다. Thread Explosion.

### 번외 - 비동기와 동시성
- serial, concurrent, sync, async
- serial과 concurrent는 작업 Queue의 작동 방식이다.
  - 전자는 끝나는 순서를 보장하며, 후자는 끝나는 순서를 보장하지 않는다.
  - 큐이므로 시작하는 순서는 보장한다.
  - 동시에 작업하는 것처럼 보이도록, Round Robin과 유사한 느낌으로 작동한다.
- sync와 async는 제어권의 유무와 관련이 있다.
  - 전자는 제어권을 넘김으로써, 작업 결과를 기다린다.
  - 후자는 제어권을 넘기지 않음으로써, 작업을 위임하고 callback 등의 수단을 통해 종료 알림과 결과를 받는다.

### 번외 - Mutex와 Semaphore
- 스레드가 공용 메모리 구역(임계 구역)에 접근할 때 이를 다루는 방식.
- Mutex는 Locking 메커니즘을 사용한다. 
  - 한 번에 하나의 실행 단위만 임계구역에 접근할 수 있다.
  - Lock을 건 실행 단위만이 Lock을 풀 수 있다.
- Semaphore는 `wait()`과 `signal()` 두 개의 아토믹한 함수를 활용하는 신호 메커니즘을 사용한다.
  - 한 번에 정해진 갯수만큼의 실행 단위가 임계구역에 접근할 수 있으며, 이를 사전에 정할 수 있다.
  - 임계구역에 접근하고 있지 않은 실행 단위라도 `signal()` 함수를 사용해 접근을 해제시킬 수 있다.
  - Semaphore의 count가 1이라면 Binary Semaphore라고 하며, Mutex와 유사하게 쓸 수 있다.
- Swift에서는 NSLock으로 Mutex, DispatchSemaphore로 Semaphore를 활용할 수 있다.
- https://medium.com/@radiantchoi/data-race%EB%A5%BC-%EC%98%88%EB%B0%A9%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-3-1%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95-f86a611a139b