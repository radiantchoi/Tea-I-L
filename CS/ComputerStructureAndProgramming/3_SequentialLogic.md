# 메모리와 디스크의 핵심: 순차 논리
- 2장의 조합 논리는 입력에 의해서만 출력이 결정된다.
- 순차 논리는 조합 논리와 달리 입력의 현재 상태와 과거 상태를 함께 고려한다.

## 시간 표현과 상태 기억
- 주기 함수를 사용해 시간을 측정할 수 있다. 주기를 잘게 나눈 것이 시간이지.
  - 지구의 자전 주기를 86400으로 나누면 그게 1초다. (실제 정의는 광속을 기반으로 정의됨)
- 주기 함수는 우리도 만들 수 있다. 가령 진자가 이동하는 주기를 사용한다면!
- 다만 컴퓨터를 진자로 만들 수는 없으니까..

### 발진자
- 인버터의 출력을 입력에 먹여 피드백이 발생하면, 그것이 새 출력에 반영되어 진동하다.
- 이 값이 진동하는 속도는 회로의 전파 지연 시간에 따라 결정되며, 온도에 따라 달라진다.
- 그럼 좀 더 안정적으로 진동하는 발진자가 있다면?
- 정확한 발진자를 적은 비용으로 효율적으로 만들려면, 크리스탈을 활용하면 된다.
  - 전극을 크리스탈에 연결하고 크리스탈을 압축하면 크리스탈이 전기를 만들어낸다.
  - 전극에 전기를 가하면 크리스탈이 구부러진다. 이상은 피에조 전기라고 불린다.
  - 크리스탈 발진자는 전자적인 단극쌍투 스위치를 활용해 크리스탈에 전기를 가하고, 다시 전기를 얻어낸다. 이 주기는 예측 가능하고 정확하다.
  - 이런 용도로 쓰이는 크리스탈 중 대표적인 것이 석영. 쿼츠 시계라고 들어느 보셨나?

### 클럭
- 발진자는 컴퓨터에 클럭, 즉 시간을 셀 수 있게 해 주는 신호를 제공한다.
- 클럭은 회로의 페이스를 결정한다.
  - 최대 클럭 속도나 가장 빠른 템포는 회로의 전파 지연 시간에 의해 결정된다.
- 컴퓨터 부품의 전파 지연 시간을 표시할 때도 범위로 표시하는데, 부품별로 지연 시간이 다르기 때문이다.
- 고장 나지 않는 범위 내에서 클럭을 빠르게 공급해서 전반적인 부품 회로의 페이스를 끌어올리는 것이 오버클럭이다. (!!!)

### 래치
- 정보를 기억하는 근원!
- OR 게이트의 출력을 둘 중 하나의 입력에 다시 넣으면(반전이 없으므로 진동은 발생하지 않는다) 정보를 기억할 수 있다. OR 래치!
- 이것만으로는 출력을 0으로 다시 만들 방법이 없기 때문에, AND 게이트와 인버터를 활용해 피드백을 끊고 값을 리셋한다.
  - AND-OR 게이트 래치 (p139)
  - 액티브 로우를 사용하여, 인버터에서 발생되는 신호가 0일 때 액티브함을 나타낸다.
- S-R 래치는 액티브 로우 입력을 받고 보수 출력을 제공한다. (p139)
  - 보수 출력은 한 쪽은 액티브 하이, 다른 쪽은 액티브 로우이다.
  - NOR 게이트를 사용하면 액티브 하이 입력을 받는 S-R 래치를 만들 수 있긴 한데 비효율적이다.
  - S-R 래치는 설계가 대칭적이라 set과 reset의 지연 시간이 거의 비슷하다.
  - 주의! S-R 래치는 구동 후 초기화 로직을 통해 초깃값을 정해 주어야 한다. (p140 각주)

### 게이트가 있는 래치
- 어느 시점에 무언가를 기억한다는 건 뭘까.
- S-R 래치에 게이트를 한 쌍 추가하면, S-R 래치가 값을 기억할지 말지 정하게 할 수 있다.
- 그렇긴 한데 한쪽 입력에 인버터를 통해 추가된 1비트 입력 D의 변화가 그대로 출력에 나타난다.
  - 게이트가 열려 있는 동안 상태가 바뀌지 말아 주세요라고 비는 수 밖에 없다.
- 그럼 게이트를 여는 시간을 최소화하고, D의 변화에 맞춰 살짝 열었다 닫을 수 있다면?

### 플립 플롭
- 논리 수준이 하나에서 다른 것으로 바뀌는 중간에, 즉 엣지에서 데이터를 잡아낸다.
- 이 엣지는 시간에 대한 판정 기준이라고 생각할 수 있다.
- 엣지에 의해 데이터 변화가 촉발되는 래치를 플립 플롭이라고 부른다.
- 3개의 S-R 래치를 p.142 그림처럼 연결하면 양의 엣지에 의해 변화가 촉발되는 D 플립 플롭을 만들 수 있다.
  - 논리 수준이 0에서 1로 바뀔 때 변화가 촉발된다는 뜻이다.
  - 당연히 반대 케이스도 있겠죠!
  - 이 경우 바뀌는 논리 수준은 클럭일 것이다.
- 1비트 입력이 D인 이유는, 사실 데이터를 뜻하는 것이기 때문이었습니다!
- 즉 플립 플롭은 시간이 가는 것을 신호로 1비트 데이터의 상태를 회로 안에 전기적으로 저장한다는 뜻인 것이다!!
- 전파 지연 외에 고려할 요소로는 설정 시간, 유지 시간이 있다.
  - 설정 시간은 클럭 엣지가 발생하기 전에 얼마나 오랫동안 입력 신호를 유지해야 하는지를 나타낸다.
  - 유지 시간은 클럭 엣지가 발생한 후에 (후략)

### 카운터
- 플립 플롭을 응용해, 1 2 3 순서대로 수를 세는 카운터를 구현할 수 있다.
- p.145의 리플 카운터!
- 각 비트의 상태가 다른 비트의 상태 변화에 약간의 시차를 두고 바뀌기 때문에, 이런 회로를 비동기 회로라고 부른다.
  - 원하는 결과를 얻기 위한 시점이 언제인지 알기 어렵다는 단점이 있다.
- 비동기 회로의 단점은, 리플 가산기에서 문제 해결했던 방식을 응용해 해결할 수 있다. 동기적 카운터의 설계!
  - 상태 변화가 동기화되어 일어난다. 모든 플립 플롭에 같은 클럭을 병렬로 연결한다는 것.
- 카운터는 더 큰 회로를 만드는 기본 기능 요소로 활용할 수 있다. 그래서 독립적인 스키매틱 기호가 있다.
- 대부분의 카운터에는 카운터를 0으로 되돌리는 CLR 입력이 있다.

### 레지스터
- D 플립 플롭을 사용해 값을 기억할 수 있다는 거 기억하지?
- 레지스터는 클록을 공유하는 여러 D 플립 플롭을 한 패키지에 넣은 것이다.
- 레지스터 역시 카운터에서 본 것과 비슷한 enable 입력을 제공하는 경우가 자주 있다.

## 메모리 조직과 주소 지정
- 이제 레지스터까지 가지고 작은 정보는 저장할 수 있게 됐는데, 훨씬 많은 정보를 저장하려면??
- 레지스터를 쌓아 볼까? 그런데 어떤 레지스터를 사용해야 하는지 어떻게 지정할 수 있을까?
- 각 레지스터에 번호를 부여해 본다. 레지스터와 디코더를 활용하면 가능하며, 이를 주소라고 한다.
  - 디코더의 출력(주소값)을 레지스터 활성화를 위해 사용한다.
- 지정한 주소에 해당하는 레지스터의 출력을 선택할 방법은? 앞에서 본 셀렉터를 활용!
- 여러 메모리 컴포넌트의 출력을 하나의 출력으로 연결해야 한다면? 트라이 스테이트 출력 활용!
- 이렇게 만든 메모리 컴포넌트 회로는 p.149에 있다.
- 한편 이렇게 하면 연결 지점이 아주 많은데, 입출력을 다 하나씩 둘 수가 없으니까. 
  - 입출력 데이터 연결을 합치고 read write 제어 신호를 사용해서 연결을 줄였다.
  - 스키매틱에서 볼 수 있는 굵은 화살표는 연관된 신호로, 버스라고 부른다.
  - 주소 버스와 데이터 버스가 메모리에는 있다.
- 메모리의 주소를 행과 열의 두 덩어리로 나누고, 멀티플렉싱을 활용해 행과 열 주소 라인의 수를 반으로 줄일 수 있다.
  - 멀티플렉싱한 주소를 저장할 레지스터는 물론 필요하다!
- 행 주소와 열 주소 두 부분으로 이루어져 있기 때문에, 한 번에 모든 주소를 바꾸기보다 둘 중 하나만 바꿀 수 있으면 성능 향상이 된다.
- 메모리 칩은 깊이 * 너비로 크기를 표시하며, 너비는 행 깊이는 열이다.

### 임의 접근 메모리 (Random Access Memory)
- 이게 램의 실체다. 와!
- 메모리 중 원하는 곳 어디든, 원하는 순서로 읽고 쓰기가 가능하다.
- SRAM, 정적 램은 비싸지만 빠르다. 각 비트에 6개의 트랜지스터가 들어간다.
- DRAM은 capacitor라는 아주 작은 버킷에 전자를 담고, 트랜지스터 1개만 사용해 덮어 둔다.
  - 버킷이 새는 이슈로 인해 가끔 메모리를 리프레시해서 전자를 채워 넣어야 한다.
  - 그래서 리프레시 시간과 정보를 쓰는 시간이 겹치지 않게 주의해야 한다.
  - 한편 빛을 쪼이면 버킷이 새는 속도가 빨라지는데, 이는 디지털 카메라에 활용되는 성질이다.
- DRAM은 집적도가 높아서 큰 메모리 칩에 사용된다.
  - 그래서 주소가 많고 멀티플렉싱은 필수다.
  - 여러 사정으로 인해, 행 주소를 저장하는 속도가 열 주소를 변경하는 속도보다 더 빠르다.
  - 행을 "페이지"라고도 부른다.
  - 이건 프로그래밍에서도 중요한데, 함께 사용되는 요소들은 같은 행에 넣어 두면 성능이 훨씬 좋다.
- SRAM DRAM은 휘발성 메모리다. 전원이 끊기면 사라진다고.
- 한편 코어 메모리는 오래된 비휘발성 메모리로, 비트를 토러스 모양의 쇳조각에 저장한다.
  - 그리고 토러스의 자화 방향에 따라 0과 1을 판단한다.
  - 이러한 메모리는 가로 세로 선이 통과하는 격자에 코어가 배열된 평면의 형태이다.
  - 그리고 코어를 읽기 위한 세 번째 선, "감지" 선이 있다. 정보를 읽으려면 자화 상태를 바꾸고 읽어내야 하기 때문..

### 읽기 전용 메모리 (Read Only Memory)
- 사실은 Write Once Memory가 좀 더 정확한 표현이 아닐까.
- 한 번 쓰고 나면 여러 번 읽을 수 있다. 컴퓨터가 아닌 전자 기기에 쓸 때 유용하다.
- 가장 기초적인 형태의 ROM은 천공 카드(!!!)
  - 과거를 바탕으로 무언가 만들 수 없다면 진보가 느려진다. 오오..
- 초기 IBM 카드 리더는 탄성이 있는 선을 활용한 일종의 스위치 형태로 비트를 읽었고, 나중에는 광감지기를 활용했다.
- 코어 로프 메모리라는 것도 있다. 바느질을 통해 비트를 기록하는 것. 우주선에 쓰였다.
  - 왜 코드를 "짜다"라고 하는가.
- 종이 카드는 순차적 메모리로, 데이터를 일정한 순서로만 읽을 수 있다.다.
- 마스크 프로그래머블 ROM도 있다. 스텐실을 비트 패턴으로 바꿔서 롬에 박아넣으면 된다는 것.
  - 아무 주소나 원하는 대로 읽을 수 있다는 장점이 있다.
- Programmable ROM은 심지어 반도체 제조사에 주문하지 않고도, 직접 프로그램을 짜 넣을 수 있다! 딱 한 번만.
- 그 다음으로는 특별한 자외선을 통해 내용을 지울 수도 있는 Erasable PROM이 나왔다.
- 그 다음으로는 전기로 지울 수 있는 Electrically EPROM도 나왔다.
  - 읽고 쓰기가 가능.. 한데 좀 느리다. 접근도 자유롭게 가능하니, 사실상 RAM이다.
  - 대신 ROM 특유의 안정성도 있기 때문에 RAM 역할을 하는 ROM이 필요할 때 유용하다.

## 블록 장치
- 데이터를 이빠이 저장할 순 없을까?
- 디스크 드라이브는 이를 위해 좋은 해결책이다.
  - 헤드를 통해 데이터를 긁어 온다.
- 디스크 드라이브는 좀 느린 게, 방금 헤드를 지나간 데이터를 가져오려면 헤드를 한 바퀴 더 돌려야 한다.
  - 최근 디스크의 속도는 7200RPM 정도.
- 또 디스크 드라이브에 들어가는 기계 부품의 소모 또한 무시할 수 없다. 특히 회전축에 들어간 베어링의 마모가.
  - 기업용과 일반용의 차이는 베어링에 들어간 윤활유 양 차이라니 개웃기네
- 디스크 드라이브 또한 디스크의 일정 영역을 자화시켜 데이터를 저장하기 때문에 비휘발성이다.
- 기록 속도가 느린 대신, 기록 밀도가 높다. 주소나, 데이터 연결을 위한 공간이 필요가 없다.
- 정확히 말하면 주소를 지정하긴 한다. 블록/섹터를 원판 위에 지정해서 돌아간다.
  - 섹터당 최근에는 4096바이트까지 데이터가 들어간다.
  - 근데 이 말은 디스크에서 바이트 하나만 바꾸고 싶으면 전체 섹터를 읽고 원하는 바이트를 바꾼 다음 다시 써야 한다는 것.
    - 이거 완전 Swift struct
- 모든 섹터에 같은 비트가 들어 있는지라, 비트 밀도(bit/mm^2)는 각 원판의 안쪽이 더 높다.
  - 최신 디스크들은 이 문제를 방사상 영역, radial zone으로 구분해 해결한다.
- 탐색 시간은 헤드를 한 트랙에서 다른 트랙으로 옮길 때 드는 시간이다. 디스크는 애시당초 헤드의 위치에 따라 트랙으로 나뉜다.
- 또 원하는 데이터가 헤드 아래로 올 때까지 디스크가 도는 데까지 걸리는 시간을 회전 지연 시간이라고 한다.
- 이외의 저장 장치로 플로피 디스크, 자기 테이브, 자기 드럼, 광학 디스크가 있다.

## 플래시 메모리와 SSD
- 플래시 메모리는 최근 형태의 EEPROM이다.
  - 하지만 플래시 메모리의 버킷은 DRAM보다 더 크고 견고해서 전자가 새지 않는다.
  - 하지만하지만 버킷을 자주 여닫다 보면 연결부가 마모되어 끊어져 보린다..
  - EEPROM보다 더 빨리 지울 수 있고 더 저렴하게 만들 수 있다.
  - 내부는 블록으로 나뉘어, 블록 단위로 읽고 쓸 수 있다.
- SSD는 디스크 드라이브 모양에 넣은 플래시 메모리이다.
  - 디스크 드라이브처럼 안정적으로 쓰려고, 모든 블록의 마모 수준을 조정하는 wear-leveling 프로세서가 들어 있다.

## 오류 감지와 정정
- 복사본을 최소 세 개는 두고, 그 중 두 개 이상 일치하는 버전이 맞는다고 판단하는 기초적인 방법.
- 패리티를 사용하면 단 1비트의 데이터가 잘못된 것을 감지할 수 있다.
  - 값이 1인 비트를 미리 세 두고, 그게 짝인지 홀인지 나타내는 bool 비트를 덧붙여 둔다.
    - 모든 비트의 XOR을 통해 이런 비트를 만들 수 있다.
  - 짝수 패리티는 모든 비트를 서로 XOR한 값을 쓰며, 홀수 패리티는 XOR한 값의 보수를 활용한다.
  - 오류가 짝수 번 나면 감지하기가 힘들다.
- 한편 더 많은 비트를 사용해 더 많은 오류를 감지하는 ECC 메모리 칩도 있다.
- 패리티는 계속 변화하는 데이터에 유용하고, 그렇지 않은 데이터를 검증하는 더 저렴한 방법으로 체크섬이 있다.
  - 데이터의 각 지점을 n 비트값으로 더하고, n 비트가 넘어가는 값은 무시하는 것.
  - 사용하는 값이 클수록 위-양성 결과가 발생하기 어려워진다.
- 순환 중복 검사나 해시 코드로 데이터의 고유성을 충분히 드러내 오류를 감지할 수 있다.

## 하드웨어와 소프트웨어의 비교
- 논리를 하드웨어로 만드는 것과 소프트웨어로 만드는 것.. 의 구분은 상당히 모호하다.
  - 굳이 따지자면 소프트웨어가 만들기는 좀 더 쉽다?
- 중요한 것은 하드웨어와 소프트웨어 사이를 이어 주는 인터페이스!